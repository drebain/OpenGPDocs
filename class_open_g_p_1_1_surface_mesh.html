<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>OpenGP: OpenGP::SurfaceMesh Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OpenGP
   &#160;<span id="projectnumber">1.1</span>
   </div>
   <div id="projectbrief">Open Geometry Processing Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="tutorial.html"><span>Tutorial</span></a></li>
      <li><a href="devel.html"><span>Development</span></a></li>
      <li><a href="annotated.html"><span>Reference&#160;Manual</span></a></li>
      <li><a href="https://github.com/OpenGP/OpenGP/issues"><span>Report&#160;Bug</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>OpenGP</b></li><li class="navelem"><a class="el" href="class_open_g_p_1_1_surface_mesh.html">SurfaceMesh</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="class_open_g_p_1_1_surface_mesh-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">OpenGP::SurfaceMesh Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A halfedge data structure for polygonal meshes.  
 <a href="class_open_g_p_1_1_surface_mesh.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_surface_mesh_8h_source.html">SurfaceMesh.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for OpenGP::SurfaceMesh:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_open_g_p_1_1_surface_mesh.png" usemap="#OpenGP::SurfaceMesh_map" alt=""/>
  <map id="OpenGP::SurfaceMesh_map" name="OpenGP::SurfaceMesh_map">
<area href="class_open_g_p_1_1_global__properties.html" alt="OpenGP::Global_properties" shape="rect" coords="0,0,166,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_g_p_1_1_surface_mesh_1_1_base__handle.html">Base_handle</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_g_p_1_1_surface_mesh_1_1_edge.html">Edge</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_g_p_1_1_surface_mesh_1_1_edge__container.html">Edge_container</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_g_p_1_1_surface_mesh_1_1_edge__iterator.html">Edge_iterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_g_p_1_1_surface_mesh_1_1_edge__property.html">Edge_property</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_g_p_1_1_surface_mesh_1_1_face.html">Face</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_g_p_1_1_surface_mesh_1_1_face__around__vertex__circulator.html">Face_around_vertex_circulator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_g_p_1_1_surface_mesh_1_1_face__connectivity.html">Face_connectivity</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_g_p_1_1_surface_mesh_1_1_face__container.html">Face_container</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_g_p_1_1_surface_mesh_1_1_face__iterator.html">Face_iterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_g_p_1_1_surface_mesh_1_1_face__property.html">Face_property</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_g_p_1_1_surface_mesh_1_1_halfedge.html">Halfedge</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_g_p_1_1_surface_mesh_1_1_halfedge__around__face__circulator.html">Halfedge_around_face_circulator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_g_p_1_1_surface_mesh_1_1_halfedge__around__vertex__circulator.html">Halfedge_around_vertex_circulator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_g_p_1_1_surface_mesh_1_1_halfedge__connectivity.html">Halfedge_connectivity</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_g_p_1_1_surface_mesh_1_1_halfedge__container.html">Halfedge_container</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_g_p_1_1_surface_mesh_1_1_halfedge__iterator.html">Halfedge_iterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_g_p_1_1_surface_mesh_1_1_halfedge__property.html">Halfedge_property</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_g_p_1_1_surface_mesh_1_1_vertex.html">Vertex</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_g_p_1_1_surface_mesh_1_1_vertex__around__face__circulator.html">Vertex_around_face_circulator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_g_p_1_1_surface_mesh_1_1_vertex__around__vertex__circulator.html">Vertex_around_vertex_circulator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_g_p_1_1_surface_mesh_1_1_vertex__connectivity.html">Vertex_connectivity</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_g_p_1_1_surface_mesh_1_1_vertex__container.html">Vertex_container</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_g_p_1_1_surface_mesh_1_1_vertex__iterator.html">Vertex_iterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_g_p_1_1_surface_mesh_1_1_vertex__property.html">Vertex_property</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Construct, destruct, assignment</div></td></tr>
<tr class="memitem:ad63449accf6993ddd91bf8a2af87715e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad63449accf6993ddd91bf8a2af87715e"></a>
HEADERONLY_INLINE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_g_p_1_1_surface_mesh.html#ad63449accf6993ddd91bf8a2af87715e">SurfaceMesh</a> ()</td></tr>
<tr class="memdesc:ad63449accf6993ddd91bf8a2af87715e"><td class="mdescLeft">&#160;</td><td class="mdescRight">default constructor <br /></td></tr>
<tr class="separator:ad63449accf6993ddd91bf8a2af87715e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f9c8e574400eefde0ffa12d9d1135f0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5f9c8e574400eefde0ffa12d9d1135f0"></a>
virtual HEADERONLY_INLINE&#160;</td><td class="memItemRight" valign="bottom"><b>~SurfaceMesh</b> ()</td></tr>
<tr class="separator:a5f9c8e574400eefde0ffa12d9d1135f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac72e63729b0d734578875fac48f2a9fe"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac72e63729b0d734578875fac48f2a9fe"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_g_p_1_1_surface_mesh.html#ac72e63729b0d734578875fac48f2a9fe">SurfaceMesh</a> (const <a class="el" href="class_open_g_p_1_1_surface_mesh.html">SurfaceMesh</a> &amp;rhs)</td></tr>
<tr class="memdesc:ac72e63729b0d734578875fac48f2a9fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">copy constructor: copies <code>rhs</code> to <code>*this</code>. performs a deep copy of all properties. <br /></td></tr>
<tr class="separator:ac72e63729b0d734578875fac48f2a9fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6d78fffcd3a23bdc104f9b20e10736b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa6d78fffcd3a23bdc104f9b20e10736b"></a>
HEADERONLY_INLINE <a class="el" href="class_open_g_p_1_1_surface_mesh.html">SurfaceMesh</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_g_p_1_1_surface_mesh.html#aa6d78fffcd3a23bdc104f9b20e10736b">operator=</a> (const <a class="el" href="class_open_g_p_1_1_surface_mesh.html">SurfaceMesh</a> &amp;rhs)</td></tr>
<tr class="memdesc:aa6d78fffcd3a23bdc104f9b20e10736b"><td class="mdescLeft">&#160;</td><td class="mdescRight">assign <code>rhs</code> to <code>*this</code>. performs a deep copy of all properties. <br /></td></tr>
<tr class="separator:aa6d78fffcd3a23bdc104f9b20e10736b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ae02c97058c6fd1a7d56193b9ad4412"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8ae02c97058c6fd1a7d56193b9ad4412"></a>
HEADERONLY_INLINE <a class="el" href="class_open_g_p_1_1_surface_mesh.html">SurfaceMesh</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_g_p_1_1_surface_mesh.html#a8ae02c97058c6fd1a7d56193b9ad4412">assign</a> (const <a class="el" href="class_open_g_p_1_1_surface_mesh.html">SurfaceMesh</a> &amp;rhs)</td></tr>
<tr class="memdesc:a8ae02c97058c6fd1a7d56193b9ad4412"><td class="mdescLeft">&#160;</td><td class="mdescRight">assign <code>rhs</code> to <code>*this</code>. does not copy custom properties. <br /></td></tr>
<tr class="separator:a8ae02c97058c6fd1a7d56193b9ad4412"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">File IO</div></td></tr>
<tr class="memitem:a18e3b47a0275b670f8b0eae7f3245c63"><td class="memItemLeft" align="right" valign="top">HEADERONLY_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_g_p_1_1_surface_mesh.html#a18e3b47a0275b670f8b0eae7f3245c63">read</a> (const std::string &amp;filename)</td></tr>
<tr class="separator:a18e3b47a0275b670f8b0eae7f3245c63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f2f0dde61493534f3e9a939f9ce83ab"><td class="memItemLeft" align="right" valign="top">HEADERONLY_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_g_p_1_1_surface_mesh.html#a9f2f0dde61493534f3e9a939f9ce83ab">write</a> (const std::string &amp;filename) const </td></tr>
<tr class="separator:a9f2f0dde61493534f3e9a939f9ce83ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Add new elements by hand</div></td></tr>
<tr class="memitem:a84bfcf99e46da0ce35c520bf16ee3e4c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a84bfcf99e46da0ce35c520bf16ee3e4c"></a>
HEADERONLY_INLINE <a class="el" href="struct_open_g_p_1_1_surface_mesh_1_1_vertex.html">Vertex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_g_p_1_1_surface_mesh.html#a84bfcf99e46da0ce35c520bf16ee3e4c">add_vertex</a> (const Vec3 &amp;p)</td></tr>
<tr class="memdesc:a84bfcf99e46da0ce35c520bf16ee3e4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">add a new vertex with position <code>p</code> <br /></td></tr>
<tr class="separator:a84bfcf99e46da0ce35c520bf16ee3e4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28a835c6dc3bc22e1311651bfe608bc4"><td class="memItemLeft" align="right" valign="top">HEADERONLY_INLINE <a class="el" href="struct_open_g_p_1_1_surface_mesh_1_1_face.html">Face</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_g_p_1_1_surface_mesh.html#a28a835c6dc3bc22e1311651bfe608bc4">add_face</a> (const std::vector&lt; <a class="el" href="struct_open_g_p_1_1_surface_mesh_1_1_vertex.html">Vertex</a> &gt; &amp;<a class="el" href="class_open_g_p_1_1_surface_mesh.html#aeae7436db9b2011facfbb21f539dab88">vertices</a>)</td></tr>
<tr class="separator:a28a835c6dc3bc22e1311651bfe608bc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebc58f8d6601fc7c6953fc69f4e2b59f"><td class="memItemLeft" align="right" valign="top">HEADERONLY_INLINE <a class="el" href="struct_open_g_p_1_1_surface_mesh_1_1_face.html">Face</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_g_p_1_1_surface_mesh.html#aebc58f8d6601fc7c6953fc69f4e2b59f">add_triangle</a> (<a class="el" href="struct_open_g_p_1_1_surface_mesh_1_1_vertex.html">Vertex</a> v1, <a class="el" href="struct_open_g_p_1_1_surface_mesh_1_1_vertex.html">Vertex</a> v2, <a class="el" href="struct_open_g_p_1_1_surface_mesh_1_1_vertex.html">Vertex</a> v3)</td></tr>
<tr class="separator:aebc58f8d6601fc7c6953fc69f4e2b59f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacfc2c77dbc0ee05098f55e7ffa063b1"><td class="memItemLeft" align="right" valign="top">HEADERONLY_INLINE <a class="el" href="struct_open_g_p_1_1_surface_mesh_1_1_face.html">Face</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_g_p_1_1_surface_mesh.html#aacfc2c77dbc0ee05098f55e7ffa063b1">add_quad</a> (<a class="el" href="struct_open_g_p_1_1_surface_mesh_1_1_vertex.html">Vertex</a> v1, <a class="el" href="struct_open_g_p_1_1_surface_mesh_1_1_vertex.html">Vertex</a> v2, <a class="el" href="struct_open_g_p_1_1_surface_mesh_1_1_vertex.html">Vertex</a> v3, <a class="el" href="struct_open_g_p_1_1_surface_mesh_1_1_vertex.html">Vertex</a> v4)</td></tr>
<tr class="separator:aacfc2c77dbc0ee05098f55e7ffa063b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Memory Management</div></td></tr>
<tr class="memitem:af369a483aa3382895f0aea7b724996e9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af369a483aa3382895f0aea7b724996e9"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_g_p_1_1_surface_mesh.html#af369a483aa3382895f0aea7b724996e9">vertices_size</a> () const </td></tr>
<tr class="memdesc:af369a483aa3382895f0aea7b724996e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns number of (deleted and valid) vertices in the mesh <br /></td></tr>
<tr class="separator:af369a483aa3382895f0aea7b724996e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b93edf0066231be7f01887dbad0ead9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9b93edf0066231be7f01887dbad0ead9"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_g_p_1_1_surface_mesh.html#a9b93edf0066231be7f01887dbad0ead9">halfedges_size</a> () const </td></tr>
<tr class="memdesc:a9b93edf0066231be7f01887dbad0ead9"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns number of (deleted and valid)halfedge in the mesh <br /></td></tr>
<tr class="separator:a9b93edf0066231be7f01887dbad0ead9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19f3252002f5b2af1b0ba25a44238f64"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a19f3252002f5b2af1b0ba25a44238f64"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_g_p_1_1_surface_mesh.html#a19f3252002f5b2af1b0ba25a44238f64">edges_size</a> () const </td></tr>
<tr class="memdesc:a19f3252002f5b2af1b0ba25a44238f64"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns number of (deleted and valid)edges in the mesh <br /></td></tr>
<tr class="separator:a19f3252002f5b2af1b0ba25a44238f64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a419bb594c7799eb5a4f2e7867bcac2cc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a419bb594c7799eb5a4f2e7867bcac2cc"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_g_p_1_1_surface_mesh.html#a419bb594c7799eb5a4f2e7867bcac2cc">faces_size</a> () const </td></tr>
<tr class="memdesc:a419bb594c7799eb5a4f2e7867bcac2cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns number of (deleted and valid)faces in the mesh <br /></td></tr>
<tr class="separator:a419bb594c7799eb5a4f2e7867bcac2cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f0f9d9b2e68891018676897efd6130f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8f0f9d9b2e68891018676897efd6130f"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_g_p_1_1_surface_mesh.html#a8f0f9d9b2e68891018676897efd6130f">n_vertices</a> () const </td></tr>
<tr class="memdesc:a8f0f9d9b2e68891018676897efd6130f"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns number of vertices in the mesh <br /></td></tr>
<tr class="separator:a8f0f9d9b2e68891018676897efd6130f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63a0ff34c78f3519f035fe92bac5c523"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a63a0ff34c78f3519f035fe92bac5c523"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_g_p_1_1_surface_mesh.html#a63a0ff34c78f3519f035fe92bac5c523">n_halfedges</a> () const </td></tr>
<tr class="memdesc:a63a0ff34c78f3519f035fe92bac5c523"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns number of halfedge in the mesh <br /></td></tr>
<tr class="separator:a63a0ff34c78f3519f035fe92bac5c523"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ed195cc9997d3578d3a166bff9a5e11"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1ed195cc9997d3578d3a166bff9a5e11"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_g_p_1_1_surface_mesh.html#a1ed195cc9997d3578d3a166bff9a5e11">n_edges</a> () const </td></tr>
<tr class="memdesc:a1ed195cc9997d3578d3a166bff9a5e11"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns number of edges in the mesh <br /></td></tr>
<tr class="separator:a1ed195cc9997d3578d3a166bff9a5e11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c43b48dac0688a37c99de847b222532"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7c43b48dac0688a37c99de847b222532"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_g_p_1_1_surface_mesh.html#a7c43b48dac0688a37c99de847b222532">n_faces</a> () const </td></tr>
<tr class="memdesc:a7c43b48dac0688a37c99de847b222532"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns number of faces in the mesh <br /></td></tr>
<tr class="separator:a7c43b48dac0688a37c99de847b222532"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e71bb6614d75d42e5432e3d661fb1c4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1e71bb6614d75d42e5432e3d661fb1c4"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_g_p_1_1_surface_mesh.html#a1e71bb6614d75d42e5432e3d661fb1c4">empty</a> () const </td></tr>
<tr class="memdesc:a1e71bb6614d75d42e5432e3d661fb1c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns true iff the mesh is empty, i.e., has no vertices <br /></td></tr>
<tr class="separator:a1e71bb6614d75d42e5432e3d661fb1c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3adabfe138616588035426367befdfff"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3adabfe138616588035426367befdfff"></a>
HEADERONLY_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_g_p_1_1_surface_mesh.html#a3adabfe138616588035426367befdfff">clear</a> ()</td></tr>
<tr class="memdesc:a3adabfe138616588035426367befdfff"><td class="mdescLeft">&#160;</td><td class="mdescRight">clear mesh: remove all vertices, edges, faces <br /></td></tr>
<tr class="separator:a3adabfe138616588035426367befdfff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0efd8a1ac6353eda37c5f4aa03d283b5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0efd8a1ac6353eda37c5f4aa03d283b5"></a>
HEADERONLY_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_g_p_1_1_surface_mesh.html#a0efd8a1ac6353eda37c5f4aa03d283b5">free_memory</a> ()</td></tr>
<tr class="memdesc:a0efd8a1ac6353eda37c5f4aa03d283b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">remove unused memory from vectors <br /></td></tr>
<tr class="separator:a0efd8a1ac6353eda37c5f4aa03d283b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4b13cbfc599914d1491f89b3889fb13"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af4b13cbfc599914d1491f89b3889fb13"></a>
HEADERONLY_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_g_p_1_1_surface_mesh.html#af4b13cbfc599914d1491f89b3889fb13">reserve</a> (unsigned int nvertices, unsigned int nedges, unsigned int nfaces)</td></tr>
<tr class="memdesc:af4b13cbfc599914d1491f89b3889fb13"><td class="mdescLeft">&#160;</td><td class="mdescRight">reserve memory (mainly used in file readers) <br /></td></tr>
<tr class="separator:af4b13cbfc599914d1491f89b3889fb13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50bae0a1df19ffd477fda198c7a667bb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a50bae0a1df19ffd477fda198c7a667bb"></a>
HEADERONLY_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_g_p_1_1_surface_mesh.html#a50bae0a1df19ffd477fda198c7a667bb">garbage_collection</a> ()</td></tr>
<tr class="memdesc:a50bae0a1df19ffd477fda198c7a667bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">remove deleted vertices/edges/faces <br /></td></tr>
<tr class="separator:a50bae0a1df19ffd477fda198c7a667bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78d91e464b9c7e86c38de6c6b7ccd9e9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_g_p_1_1_surface_mesh.html#a78d91e464b9c7e86c38de6c6b7ccd9e9">is_deleted</a> (<a class="el" href="struct_open_g_p_1_1_surface_mesh_1_1_vertex.html">Vertex</a> v) const </td></tr>
<tr class="separator:a78d91e464b9c7e86c38de6c6b7ccd9e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6714d5585eb08f837ed82f0360f93272"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_g_p_1_1_surface_mesh.html#a6714d5585eb08f837ed82f0360f93272">is_deleted</a> (<a class="el" href="struct_open_g_p_1_1_surface_mesh_1_1_halfedge.html">Halfedge</a> h) const </td></tr>
<tr class="separator:a6714d5585eb08f837ed82f0360f93272"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16d0de13a19aab692447dd17d582f874"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_g_p_1_1_surface_mesh.html#a16d0de13a19aab692447dd17d582f874">is_deleted</a> (<a class="el" href="struct_open_g_p_1_1_surface_mesh_1_1_edge.html">Edge</a> e) const </td></tr>
<tr class="separator:a16d0de13a19aab692447dd17d582f874"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a753af7604251aedf6f832671f7cb0cd1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_g_p_1_1_surface_mesh.html#a753af7604251aedf6f832671f7cb0cd1">is_deleted</a> (<a class="el" href="struct_open_g_p_1_1_surface_mesh_1_1_face.html">Face</a> f) const </td></tr>
<tr class="separator:a753af7604251aedf6f832671f7cb0cd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bddbc9bf3cfa02d3bfb1515b5646236"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3bddbc9bf3cfa02d3bfb1515b5646236"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_g_p_1_1_surface_mesh.html#a3bddbc9bf3cfa02d3bfb1515b5646236">is_valid</a> (<a class="el" href="struct_open_g_p_1_1_surface_mesh_1_1_vertex.html">Vertex</a> v) const </td></tr>
<tr class="memdesc:a3bddbc9bf3cfa02d3bfb1515b5646236"><td class="mdescLeft">&#160;</td><td class="mdescRight">return whether vertex <code>v</code> is valid, i.e. the index is stores it within the array bounds. <br /></td></tr>
<tr class="separator:a3bddbc9bf3cfa02d3bfb1515b5646236"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15f032b5bf5e859d4588c31eeab2a020"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a15f032b5bf5e859d4588c31eeab2a020"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_g_p_1_1_surface_mesh.html#a15f032b5bf5e859d4588c31eeab2a020">is_valid</a> (<a class="el" href="struct_open_g_p_1_1_surface_mesh_1_1_halfedge.html">Halfedge</a> h) const </td></tr>
<tr class="memdesc:a15f032b5bf5e859d4588c31eeab2a020"><td class="mdescLeft">&#160;</td><td class="mdescRight">return whether halfedge <code>h</code> is valid, i.e. the index is stores it within the array bounds. <br /></td></tr>
<tr class="separator:a15f032b5bf5e859d4588c31eeab2a020"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7715448e3ceaa0cc2df4c83346be4faa"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7715448e3ceaa0cc2df4c83346be4faa"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_g_p_1_1_surface_mesh.html#a7715448e3ceaa0cc2df4c83346be4faa">is_valid</a> (<a class="el" href="struct_open_g_p_1_1_surface_mesh_1_1_edge.html">Edge</a> e) const </td></tr>
<tr class="memdesc:a7715448e3ceaa0cc2df4c83346be4faa"><td class="mdescLeft">&#160;</td><td class="mdescRight">return whether edge <code>e</code> is valid, i.e. the index is stores it within the array bounds. <br /></td></tr>
<tr class="separator:a7715448e3ceaa0cc2df4c83346be4faa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2594fbf9b5b2569495fbc055782351dd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2594fbf9b5b2569495fbc055782351dd"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_g_p_1_1_surface_mesh.html#a2594fbf9b5b2569495fbc055782351dd">is_valid</a> (<a class="el" href="struct_open_g_p_1_1_surface_mesh_1_1_face.html">Face</a> f) const </td></tr>
<tr class="memdesc:a2594fbf9b5b2569495fbc055782351dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">return whether face <code>f</code> is valid, i.e. the index is stores it within the array bounds. <br /></td></tr>
<tr class="separator:a2594fbf9b5b2569495fbc055782351dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Low-level connectivity</div></td></tr>
<tr class="memitem:a12c37f7dc06cd9b8fd9efc56d1d1b330"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_open_g_p_1_1_surface_mesh_1_1_halfedge.html">Halfedge</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_g_p_1_1_surface_mesh.html#a12c37f7dc06cd9b8fd9efc56d1d1b330">halfedge</a> (<a class="el" href="struct_open_g_p_1_1_surface_mesh_1_1_vertex.html">Vertex</a> v) const </td></tr>
<tr class="separator:a12c37f7dc06cd9b8fd9efc56d1d1b330"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac762b76d67f6cc49eb17eb19948aa21d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac762b76d67f6cc49eb17eb19948aa21d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_g_p_1_1_surface_mesh.html#ac762b76d67f6cc49eb17eb19948aa21d">set_halfedge</a> (<a class="el" href="struct_open_g_p_1_1_surface_mesh_1_1_vertex.html">Vertex</a> v, <a class="el" href="struct_open_g_p_1_1_surface_mesh_1_1_halfedge.html">Halfedge</a> h)</td></tr>
<tr class="memdesc:ac762b76d67f6cc49eb17eb19948aa21d"><td class="mdescLeft">&#160;</td><td class="mdescRight">set the outgoing halfedge of vertex <code>v</code> to <code>h</code> <br /></td></tr>
<tr class="separator:ac762b76d67f6cc49eb17eb19948aa21d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0c816094824583e72f39d292cd747ed"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa0c816094824583e72f39d292cd747ed"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_g_p_1_1_surface_mesh.html#aa0c816094824583e72f39d292cd747ed">is_boundary</a> (<a class="el" href="struct_open_g_p_1_1_surface_mesh_1_1_vertex.html">Vertex</a> v) const </td></tr>
<tr class="memdesc:aa0c816094824583e72f39d292cd747ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns whether <code>v</code> is a boundary vertex <br /></td></tr>
<tr class="separator:aa0c816094824583e72f39d292cd747ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf74f8181823773775888b347bdfa52d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acf74f8181823773775888b347bdfa52d"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_g_p_1_1_surface_mesh.html#acf74f8181823773775888b347bdfa52d">is_isolated</a> (<a class="el" href="struct_open_g_p_1_1_surface_mesh_1_1_vertex.html">Vertex</a> v) const </td></tr>
<tr class="memdesc:acf74f8181823773775888b347bdfa52d"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns whether <code>v</code> is isolated, i.e., not incident to any face <br /></td></tr>
<tr class="separator:acf74f8181823773775888b347bdfa52d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3d30d0b895fb93b5e12278376248420"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae3d30d0b895fb93b5e12278376248420"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_g_p_1_1_surface_mesh.html#ae3d30d0b895fb93b5e12278376248420">is_manifold</a> (<a class="el" href="struct_open_g_p_1_1_surface_mesh_1_1_vertex.html">Vertex</a> v) const </td></tr>
<tr class="memdesc:ae3d30d0b895fb93b5e12278376248420"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns whether <code>v</code> is a manifold vertex (not incident to several patches) <br /></td></tr>
<tr class="separator:ae3d30d0b895fb93b5e12278376248420"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f7ba842d55d4bdb110fafc1db07b9bb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1f7ba842d55d4bdb110fafc1db07b9bb"></a>
<a class="el" href="struct_open_g_p_1_1_surface_mesh_1_1_vertex.html">Vertex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_g_p_1_1_surface_mesh.html#a1f7ba842d55d4bdb110fafc1db07b9bb">to_vertex</a> (<a class="el" href="struct_open_g_p_1_1_surface_mesh_1_1_halfedge.html">Halfedge</a> h) const </td></tr>
<tr class="memdesc:a1f7ba842d55d4bdb110fafc1db07b9bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the vertex the halfedge <code>h</code> points to <br /></td></tr>
<tr class="separator:a1f7ba842d55d4bdb110fafc1db07b9bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24e7990fea324ad5fac69555e6ece8c4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a24e7990fea324ad5fac69555e6ece8c4"></a>
<a class="el" href="struct_open_g_p_1_1_surface_mesh_1_1_vertex.html">Vertex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_g_p_1_1_surface_mesh.html#a24e7990fea324ad5fac69555e6ece8c4">from_vertex</a> (<a class="el" href="struct_open_g_p_1_1_surface_mesh_1_1_halfedge.html">Halfedge</a> h) const </td></tr>
<tr class="memdesc:a24e7990fea324ad5fac69555e6ece8c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the vertex the halfedge <code>h</code> emanates from <br /></td></tr>
<tr class="separator:a24e7990fea324ad5fac69555e6ece8c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35346f4542bbc8b0480a260b2862df8d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a35346f4542bbc8b0480a260b2862df8d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_g_p_1_1_surface_mesh.html#a35346f4542bbc8b0480a260b2862df8d">set_vertex</a> (<a class="el" href="struct_open_g_p_1_1_surface_mesh_1_1_halfedge.html">Halfedge</a> h, <a class="el" href="struct_open_g_p_1_1_surface_mesh_1_1_vertex.html">Vertex</a> v)</td></tr>
<tr class="memdesc:a35346f4542bbc8b0480a260b2862df8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">sets the vertex the halfedge <code>h</code> points to to <code>v</code> <br /></td></tr>
<tr class="separator:a35346f4542bbc8b0480a260b2862df8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae68b67a560502aa22a33593e1c5df651"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae68b67a560502aa22a33593e1c5df651"></a>
<a class="el" href="struct_open_g_p_1_1_surface_mesh_1_1_face.html">Face</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_g_p_1_1_surface_mesh.html#ae68b67a560502aa22a33593e1c5df651">face</a> (<a class="el" href="struct_open_g_p_1_1_surface_mesh_1_1_halfedge.html">Halfedge</a> h) const </td></tr>
<tr class="memdesc:ae68b67a560502aa22a33593e1c5df651"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the face incident to halfedge <code>h</code> <br /></td></tr>
<tr class="separator:ae68b67a560502aa22a33593e1c5df651"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19b2975c689048710d87cddb6d35ded2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a19b2975c689048710d87cddb6d35ded2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_g_p_1_1_surface_mesh.html#a19b2975c689048710d87cddb6d35ded2">set_face</a> (<a class="el" href="struct_open_g_p_1_1_surface_mesh_1_1_halfedge.html">Halfedge</a> h, <a class="el" href="struct_open_g_p_1_1_surface_mesh_1_1_face.html">Face</a> f)</td></tr>
<tr class="memdesc:a19b2975c689048710d87cddb6d35ded2"><td class="mdescLeft">&#160;</td><td class="mdescRight">sets the incident face to halfedge <code>h</code> to <code>f</code> <br /></td></tr>
<tr class="separator:a19b2975c689048710d87cddb6d35ded2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dd8a038f53e0a394c8a413fa9a91dcb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9dd8a038f53e0a394c8a413fa9a91dcb"></a>
<a class="el" href="struct_open_g_p_1_1_surface_mesh_1_1_halfedge.html">Halfedge</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_g_p_1_1_surface_mesh.html#a9dd8a038f53e0a394c8a413fa9a91dcb">next_halfedge</a> (<a class="el" href="struct_open_g_p_1_1_surface_mesh_1_1_halfedge.html">Halfedge</a> h) const </td></tr>
<tr class="memdesc:a9dd8a038f53e0a394c8a413fa9a91dcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the next halfedge within the incident face <br /></td></tr>
<tr class="separator:a9dd8a038f53e0a394c8a413fa9a91dcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0257f6675248075e80abaa1e7636b261"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0257f6675248075e80abaa1e7636b261"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_g_p_1_1_surface_mesh.html#a0257f6675248075e80abaa1e7636b261">set_next_halfedge</a> (<a class="el" href="struct_open_g_p_1_1_surface_mesh_1_1_halfedge.html">Halfedge</a> h, <a class="el" href="struct_open_g_p_1_1_surface_mesh_1_1_halfedge.html">Halfedge</a> nh)</td></tr>
<tr class="memdesc:a0257f6675248075e80abaa1e7636b261"><td class="mdescLeft">&#160;</td><td class="mdescRight">sets the next halfedge of <code>h</code> within the face to <code>nh</code> <br /></td></tr>
<tr class="separator:a0257f6675248075e80abaa1e7636b261"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d1a4c3db3732d29d049888c9574e825"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1d1a4c3db3732d29d049888c9574e825"></a>
<a class="el" href="struct_open_g_p_1_1_surface_mesh_1_1_halfedge.html">Halfedge</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_g_p_1_1_surface_mesh.html#a1d1a4c3db3732d29d049888c9574e825">prev_halfedge</a> (<a class="el" href="struct_open_g_p_1_1_surface_mesh_1_1_halfedge.html">Halfedge</a> h) const </td></tr>
<tr class="memdesc:a1d1a4c3db3732d29d049888c9574e825"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the previous halfedge within the incident face <br /></td></tr>
<tr class="separator:a1d1a4c3db3732d29d049888c9574e825"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae747c6cfedc33361606393f40564d475"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae747c6cfedc33361606393f40564d475"></a>
<a class="el" href="struct_open_g_p_1_1_surface_mesh_1_1_halfedge.html">Halfedge</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_g_p_1_1_surface_mesh.html#ae747c6cfedc33361606393f40564d475">opposite_halfedge</a> (<a class="el" href="struct_open_g_p_1_1_surface_mesh_1_1_halfedge.html">Halfedge</a> h) const </td></tr>
<tr class="memdesc:ae747c6cfedc33361606393f40564d475"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the opposite halfedge of <code>h</code> <br /></td></tr>
<tr class="separator:ae747c6cfedc33361606393f40564d475"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9741a73c925d629cbdb02893d38c6271"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_open_g_p_1_1_surface_mesh_1_1_halfedge.html">Halfedge</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_g_p_1_1_surface_mesh.html#a9741a73c925d629cbdb02893d38c6271">ccw_rotated_halfedge</a> (<a class="el" href="struct_open_g_p_1_1_surface_mesh_1_1_halfedge.html">Halfedge</a> h) const </td></tr>
<tr class="separator:a9741a73c925d629cbdb02893d38c6271"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91921c2d2a46f08f7c02456ca9275a9e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_open_g_p_1_1_surface_mesh_1_1_halfedge.html">Halfedge</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_g_p_1_1_surface_mesh.html#a91921c2d2a46f08f7c02456ca9275a9e">cw_rotated_halfedge</a> (<a class="el" href="struct_open_g_p_1_1_surface_mesh_1_1_halfedge.html">Halfedge</a> h) const </td></tr>
<tr class="separator:a91921c2d2a46f08f7c02456ca9275a9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa22f2ec07cae930e64cbed22a831a9f0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa22f2ec07cae930e64cbed22a831a9f0"></a>
<a class="el" href="struct_open_g_p_1_1_surface_mesh_1_1_edge.html">Edge</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_g_p_1_1_surface_mesh.html#aa22f2ec07cae930e64cbed22a831a9f0">edge</a> (<a class="el" href="struct_open_g_p_1_1_surface_mesh_1_1_halfedge.html">Halfedge</a> h) const </td></tr>
<tr class="memdesc:aa22f2ec07cae930e64cbed22a831a9f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the edge that contains halfedge <code>h</code> as one of its two halfedges. <br /></td></tr>
<tr class="separator:aa22f2ec07cae930e64cbed22a831a9f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8e894247752939a13c64890fc14214c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa8e894247752939a13c64890fc14214c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_g_p_1_1_surface_mesh.html#aa8e894247752939a13c64890fc14214c">is_boundary</a> (<a class="el" href="struct_open_g_p_1_1_surface_mesh_1_1_halfedge.html">Halfedge</a> h) const </td></tr>
<tr class="memdesc:aa8e894247752939a13c64890fc14214c"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns whether h is a boundary halfege, i.e., if its face does not exist. <br /></td></tr>
<tr class="separator:aa8e894247752939a13c64890fc14214c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae59f9a5eb5f47427ac33b6c826d8dc50"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae59f9a5eb5f47427ac33b6c826d8dc50"></a>
<a class="el" href="struct_open_g_p_1_1_surface_mesh_1_1_halfedge.html">Halfedge</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_g_p_1_1_surface_mesh.html#ae59f9a5eb5f47427ac33b6c826d8dc50">halfedge</a> (<a class="el" href="struct_open_g_p_1_1_surface_mesh_1_1_edge.html">Edge</a> e, unsigned int i) const </td></tr>
<tr class="memdesc:ae59f9a5eb5f47427ac33b6c826d8dc50"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the <code>i'th</code> halfedge of edge <code>e</code>. <code>i</code> has to be 0 or 1. <br /></td></tr>
<tr class="separator:ae59f9a5eb5f47427ac33b6c826d8dc50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad32dc1efbe1994b6d4f6ee76ba191722"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad32dc1efbe1994b6d4f6ee76ba191722"></a>
<a class="el" href="struct_open_g_p_1_1_surface_mesh_1_1_vertex.html">Vertex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_g_p_1_1_surface_mesh.html#ad32dc1efbe1994b6d4f6ee76ba191722">vertex</a> (<a class="el" href="struct_open_g_p_1_1_surface_mesh_1_1_edge.html">Edge</a> e, unsigned int i) const </td></tr>
<tr class="memdesc:ad32dc1efbe1994b6d4f6ee76ba191722"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the <code>i'th</code> vertex of edge <code>e</code>. <code>i</code> has to be 0 or 1. <br /></td></tr>
<tr class="separator:ad32dc1efbe1994b6d4f6ee76ba191722"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97b67a55a91cfc49fb2bcd373a2dd453"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a97b67a55a91cfc49fb2bcd373a2dd453"></a>
<a class="el" href="struct_open_g_p_1_1_surface_mesh_1_1_face.html">Face</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_g_p_1_1_surface_mesh.html#a97b67a55a91cfc49fb2bcd373a2dd453">face</a> (<a class="el" href="struct_open_g_p_1_1_surface_mesh_1_1_edge.html">Edge</a> e, unsigned int i) const </td></tr>
<tr class="memdesc:a97b67a55a91cfc49fb2bcd373a2dd453"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the face incident to the <code>i'th</code> halfedge of edge <code>e</code>. <code>i</code> has to be 0 or 1. <br /></td></tr>
<tr class="separator:a97b67a55a91cfc49fb2bcd373a2dd453"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afea5aedb652cc9e55aeae5dd2e6c7e6d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_g_p_1_1_surface_mesh.html#afea5aedb652cc9e55aeae5dd2e6c7e6d">is_boundary</a> (<a class="el" href="struct_open_g_p_1_1_surface_mesh_1_1_edge.html">Edge</a> e) const </td></tr>
<tr class="separator:afea5aedb652cc9e55aeae5dd2e6c7e6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c47be2092bcf49c1ff0b0b31fff4a39"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0c47be2092bcf49c1ff0b0b31fff4a39"></a>
<a class="el" href="struct_open_g_p_1_1_surface_mesh_1_1_halfedge.html">Halfedge</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_g_p_1_1_surface_mesh.html#a0c47be2092bcf49c1ff0b0b31fff4a39">halfedge</a> (<a class="el" href="struct_open_g_p_1_1_surface_mesh_1_1_face.html">Face</a> f) const </td></tr>
<tr class="memdesc:a0c47be2092bcf49c1ff0b0b31fff4a39"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a halfedge of face <code>f</code> <br /></td></tr>
<tr class="separator:a0c47be2092bcf49c1ff0b0b31fff4a39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71141bb1096708a6baa167401b56ec58"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a71141bb1096708a6baa167401b56ec58"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_g_p_1_1_surface_mesh.html#a71141bb1096708a6baa167401b56ec58">set_halfedge</a> (<a class="el" href="struct_open_g_p_1_1_surface_mesh_1_1_face.html">Face</a> f, <a class="el" href="struct_open_g_p_1_1_surface_mesh_1_1_halfedge.html">Halfedge</a> h)</td></tr>
<tr class="memdesc:a71141bb1096708a6baa167401b56ec58"><td class="mdescLeft">&#160;</td><td class="mdescRight">sets the halfedge of face <code>f</code> to <code>h</code> <br /></td></tr>
<tr class="separator:a71141bb1096708a6baa167401b56ec58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a76bc861133478f96d2b5e48d5c738d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3a76bc861133478f96d2b5e48d5c738d"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_g_p_1_1_surface_mesh.html#a3a76bc861133478f96d2b5e48d5c738d">is_boundary</a> (<a class="el" href="struct_open_g_p_1_1_surface_mesh_1_1_face.html">Face</a> f) const </td></tr>
<tr class="memdesc:a3a76bc861133478f96d2b5e48d5c738d"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns whether <code>f</code> is a boundary face, i.e., it one of its edges is a boundary edge. <br /></td></tr>
<tr class="separator:a3a76bc861133478f96d2b5e48d5c738d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Property handling</div></td></tr>
<tr class="memitem:ac93a3b5012953c091ec40949a6f474a7"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ac93a3b5012953c091ec40949a6f474a7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_open_g_p_1_1_surface_mesh_1_1_vertex__property.html">Vertex_property</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_open_g_p_1_1_surface_mesh.html#ac93a3b5012953c091ec40949a6f474a7">add_vertex_property</a> (const std::string &amp;name, const T t=T())</td></tr>
<tr class="separator:ac93a3b5012953c091ec40949a6f474a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9820779f524dbd1ec4cfd886f1f7e5f8"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a9820779f524dbd1ec4cfd886f1f7e5f8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_open_g_p_1_1_surface_mesh_1_1_halfedge__property.html">Halfedge_property</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_open_g_p_1_1_surface_mesh.html#a9820779f524dbd1ec4cfd886f1f7e5f8">add_halfedge_property</a> (const std::string &amp;name, const T t=T())</td></tr>
<tr class="separator:a9820779f524dbd1ec4cfd886f1f7e5f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ce75b6bf0efe4f21ef2391399979759"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a1ce75b6bf0efe4f21ef2391399979759"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_open_g_p_1_1_surface_mesh_1_1_edge__property.html">Edge_property</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_open_g_p_1_1_surface_mesh.html#a1ce75b6bf0efe4f21ef2391399979759">add_edge_property</a> (const std::string &amp;name, const T t=T())</td></tr>
<tr class="separator:a1ce75b6bf0efe4f21ef2391399979759"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bd42b305af291b75b08d643592365ac"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a9bd42b305af291b75b08d643592365ac"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_open_g_p_1_1_surface_mesh_1_1_face__property.html">Face_property</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_open_g_p_1_1_surface_mesh.html#a9bd42b305af291b75b08d643592365ac">add_face_property</a> (const std::string &amp;name, const T t=T())</td></tr>
<tr class="separator:a9bd42b305af291b75b08d643592365ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49a79a62cd065f66edc0dff5ddb6687e"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a49a79a62cd065f66edc0dff5ddb6687e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_open_g_p_1_1_surface_mesh_1_1_vertex__property.html">Vertex_property</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_open_g_p_1_1_surface_mesh.html#a49a79a62cd065f66edc0dff5ddb6687e">get_vertex_property</a> (const std::string &amp;name) const </td></tr>
<tr class="separator:a49a79a62cd065f66edc0dff5ddb6687e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d9c25281115f9859b0c08f30184f99f"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a5d9c25281115f9859b0c08f30184f99f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_open_g_p_1_1_surface_mesh_1_1_halfedge__property.html">Halfedge_property</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_open_g_p_1_1_surface_mesh.html#a5d9c25281115f9859b0c08f30184f99f">get_halfedge_property</a> (const std::string &amp;name) const </td></tr>
<tr class="separator:a5d9c25281115f9859b0c08f30184f99f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a861117410179fea7aeaa377d9eb83094"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a861117410179fea7aeaa377d9eb83094"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_open_g_p_1_1_surface_mesh_1_1_edge__property.html">Edge_property</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_open_g_p_1_1_surface_mesh.html#a861117410179fea7aeaa377d9eb83094">get_edge_property</a> (const std::string &amp;name) const </td></tr>
<tr class="separator:a861117410179fea7aeaa377d9eb83094"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dab64eda7de98f10f5b9cc9988a3b90"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a9dab64eda7de98f10f5b9cc9988a3b90"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_open_g_p_1_1_surface_mesh_1_1_face__property.html">Face_property</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_open_g_p_1_1_surface_mesh.html#a9dab64eda7de98f10f5b9cc9988a3b90">get_face_property</a> (const std::string &amp;name) const </td></tr>
<tr class="separator:a9dab64eda7de98f10f5b9cc9988a3b90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a037d2df1a2ddf83297a81222de6e55c8"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a037d2df1a2ddf83297a81222de6e55c8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_open_g_p_1_1_surface_mesh_1_1_vertex__property.html">Vertex_property</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_open_g_p_1_1_surface_mesh.html#a037d2df1a2ddf83297a81222de6e55c8">vertex_property</a> (const std::string &amp;name, const T t=T())</td></tr>
<tr class="separator:a037d2df1a2ddf83297a81222de6e55c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbdd898243df2b8ef06ce23759f0b2c6"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:abbdd898243df2b8ef06ce23759f0b2c6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_open_g_p_1_1_surface_mesh_1_1_halfedge__property.html">Halfedge_property</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_open_g_p_1_1_surface_mesh.html#abbdd898243df2b8ef06ce23759f0b2c6">halfedge_property</a> (const std::string &amp;name, const T t=T())</td></tr>
<tr class="separator:abbdd898243df2b8ef06ce23759f0b2c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafec0b6da843682831e0740409844a80"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:aafec0b6da843682831e0740409844a80"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_open_g_p_1_1_surface_mesh_1_1_edge__property.html">Edge_property</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_open_g_p_1_1_surface_mesh.html#aafec0b6da843682831e0740409844a80">edge_property</a> (const std::string &amp;name, const T t=T())</td></tr>
<tr class="separator:aafec0b6da843682831e0740409844a80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf2c8bf7e23b6419661bf69417165ef8"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:aaf2c8bf7e23b6419661bf69417165ef8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_open_g_p_1_1_surface_mesh_1_1_face__property.html">Face_property</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_open_g_p_1_1_surface_mesh.html#aaf2c8bf7e23b6419661bf69417165ef8">face_property</a> (const std::string &amp;name, const T t=T())</td></tr>
<tr class="separator:aaf2c8bf7e23b6419661bf69417165ef8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98b709643c2f6858b4ee8b9e5af730de"><td class="memTemplParams" colspan="2"><a class="anchor" id="a98b709643c2f6858b4ee8b9e5af730de"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a98b709643c2f6858b4ee8b9e5af730de"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_open_g_p_1_1_surface_mesh.html#a98b709643c2f6858b4ee8b9e5af730de">remove_vertex_property</a> (<a class="el" href="class_open_g_p_1_1_surface_mesh_1_1_vertex__property.html">Vertex_property</a>&lt; T &gt; &amp;p)</td></tr>
<tr class="memdesc:a98b709643c2f6858b4ee8b9e5af730de"><td class="mdescLeft">&#160;</td><td class="mdescRight">remove the vertex property <code>p</code> <br /></td></tr>
<tr class="separator:a98b709643c2f6858b4ee8b9e5af730de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3da93abd9206e122a3feaf01d3988446"><td class="memTemplParams" colspan="2"><a class="anchor" id="a3da93abd9206e122a3feaf01d3988446"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a3da93abd9206e122a3feaf01d3988446"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_open_g_p_1_1_surface_mesh.html#a3da93abd9206e122a3feaf01d3988446">remove_halfedge_property</a> (<a class="el" href="class_open_g_p_1_1_surface_mesh_1_1_halfedge__property.html">Halfedge_property</a>&lt; T &gt; &amp;p)</td></tr>
<tr class="memdesc:a3da93abd9206e122a3feaf01d3988446"><td class="mdescLeft">&#160;</td><td class="mdescRight">remove the halfedge property <code>p</code> <br /></td></tr>
<tr class="separator:a3da93abd9206e122a3feaf01d3988446"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a794613deae5d83cef41de5f838f605aa"><td class="memTemplParams" colspan="2"><a class="anchor" id="a794613deae5d83cef41de5f838f605aa"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a794613deae5d83cef41de5f838f605aa"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_open_g_p_1_1_surface_mesh.html#a794613deae5d83cef41de5f838f605aa">remove_edge_property</a> (<a class="el" href="class_open_g_p_1_1_surface_mesh_1_1_edge__property.html">Edge_property</a>&lt; T &gt; &amp;p)</td></tr>
<tr class="memdesc:a794613deae5d83cef41de5f838f605aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">remove the edge property <code>p</code> <br /></td></tr>
<tr class="separator:a794613deae5d83cef41de5f838f605aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56c4dfbf137a508b808f65372f7bd4e9"><td class="memTemplParams" colspan="2"><a class="anchor" id="a56c4dfbf137a508b808f65372f7bd4e9"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a56c4dfbf137a508b808f65372f7bd4e9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_open_g_p_1_1_surface_mesh.html#a56c4dfbf137a508b808f65372f7bd4e9">remove_face_property</a> (<a class="el" href="class_open_g_p_1_1_surface_mesh_1_1_face__property.html">Face_property</a>&lt; T &gt; &amp;p)</td></tr>
<tr class="memdesc:a56c4dfbf137a508b808f65372f7bd4e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">remove the face property <code>p</code> <br /></td></tr>
<tr class="separator:a56c4dfbf137a508b808f65372f7bd4e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84fb77097285be6cdd85d3505e81fbb8"><td class="memItemLeft" align="right" valign="top">const std::type_info &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_g_p_1_1_surface_mesh.html#a84fb77097285be6cdd85d3505e81fbb8">get_vertex_property_type</a> (const std::string &amp;name)</td></tr>
<tr class="separator:a84fb77097285be6cdd85d3505e81fbb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cbf036a0782f154f3f66b1545d19ffc"><td class="memItemLeft" align="right" valign="top">const std::type_info &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_g_p_1_1_surface_mesh.html#a8cbf036a0782f154f3f66b1545d19ffc">get_halfedge_property_type</a> (const std::string &amp;name)</td></tr>
<tr class="separator:a8cbf036a0782f154f3f66b1545d19ffc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ec6f27be502753c245aa81615b799d6"><td class="memItemLeft" align="right" valign="top">const std::type_info &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_g_p_1_1_surface_mesh.html#a2ec6f27be502753c245aa81615b799d6">get_edge_property_type</a> (const std::string &amp;name)</td></tr>
<tr class="separator:a2ec6f27be502753c245aa81615b799d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5162436ae6ba4e5b6282790d979b265"><td class="memItemLeft" align="right" valign="top">const std::type_info &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_g_p_1_1_surface_mesh.html#ad5162436ae6ba4e5b6282790d979b265">get_face_property_type</a> (const std::string &amp;name)</td></tr>
<tr class="separator:ad5162436ae6ba4e5b6282790d979b265"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a059a294783211f6729571070197a1668"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a059a294783211f6729571070197a1668"></a>
std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_g_p_1_1_surface_mesh.html#a059a294783211f6729571070197a1668">vertex_properties</a> () const </td></tr>
<tr class="memdesc:a059a294783211f6729571070197a1668"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the names of all vertex properties <br /></td></tr>
<tr class="separator:a059a294783211f6729571070197a1668"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab982a61330a2eb4bf0affb4fe8e995b5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab982a61330a2eb4bf0affb4fe8e995b5"></a>
std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_g_p_1_1_surface_mesh.html#ab982a61330a2eb4bf0affb4fe8e995b5">halfedge_properties</a> () const </td></tr>
<tr class="memdesc:ab982a61330a2eb4bf0affb4fe8e995b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the names of all halfedge properties <br /></td></tr>
<tr class="separator:ab982a61330a2eb4bf0affb4fe8e995b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73eb9d72d3df12188ad78ede0b9d4359"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a73eb9d72d3df12188ad78ede0b9d4359"></a>
std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_g_p_1_1_surface_mesh.html#a73eb9d72d3df12188ad78ede0b9d4359">edge_properties</a> () const </td></tr>
<tr class="memdesc:a73eb9d72d3df12188ad78ede0b9d4359"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the names of all edge properties <br /></td></tr>
<tr class="separator:a73eb9d72d3df12188ad78ede0b9d4359"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5edcfb16a0f747263e45f65a47696fd6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5edcfb16a0f747263e45f65a47696fd6"></a>
std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_g_p_1_1_surface_mesh.html#a5edcfb16a0f747263e45f65a47696fd6">face_properties</a> () const </td></tr>
<tr class="memdesc:a5edcfb16a0f747263e45f65a47696fd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the names of all face properties <br /></td></tr>
<tr class="separator:a5edcfb16a0f747263e45f65a47696fd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a273d70421b6f04ec830daf686bb9c4ae"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a273d70421b6f04ec830daf686bb9c4ae"></a>
HEADERONLY_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_g_p_1_1_surface_mesh.html#a273d70421b6f04ec830daf686bb9c4ae">property_stats</a> () const </td></tr>
<tr class="memdesc:a273d70421b6f04ec830daf686bb9c4ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">prints the names of all properties <br /></td></tr>
<tr class="separator:a273d70421b6f04ec830daf686bb9c4ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Iterators &amp; Circulators</div></td></tr>
<tr class="memitem:aaec7881d50ee98937e696f4fe0f50165"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaec7881d50ee98937e696f4fe0f50165"></a>
<a class="el" href="class_open_g_p_1_1_surface_mesh_1_1_vertex__iterator.html">Vertex_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_g_p_1_1_surface_mesh.html#aaec7881d50ee98937e696f4fe0f50165">vertices_begin</a> () const </td></tr>
<tr class="memdesc:aaec7881d50ee98937e696f4fe0f50165"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns start iterator for vertices <br /></td></tr>
<tr class="separator:aaec7881d50ee98937e696f4fe0f50165"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c74d8232746b48b89aebb7b6e5f0cf3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5c74d8232746b48b89aebb7b6e5f0cf3"></a>
<a class="el" href="class_open_g_p_1_1_surface_mesh_1_1_vertex__iterator.html">Vertex_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_g_p_1_1_surface_mesh.html#a5c74d8232746b48b89aebb7b6e5f0cf3">vertices_end</a> () const </td></tr>
<tr class="memdesc:a5c74d8232746b48b89aebb7b6e5f0cf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns end iterator for vertices <br /></td></tr>
<tr class="separator:a5c74d8232746b48b89aebb7b6e5f0cf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeae7436db9b2011facfbb21f539dab88"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeae7436db9b2011facfbb21f539dab88"></a>
<a class="el" href="class_open_g_p_1_1_surface_mesh_1_1_vertex__container.html">Vertex_container</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_g_p_1_1_surface_mesh.html#aeae7436db9b2011facfbb21f539dab88">vertices</a> () const </td></tr>
<tr class="memdesc:aeae7436db9b2011facfbb21f539dab88"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns vertex container for C++11 range-based for-loops <br /></td></tr>
<tr class="separator:aeae7436db9b2011facfbb21f539dab88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32344e0120b2148cb649be85df1b2a34"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a32344e0120b2148cb649be85df1b2a34"></a>
<a class="el" href="class_open_g_p_1_1_surface_mesh_1_1_halfedge__iterator.html">Halfedge_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_g_p_1_1_surface_mesh.html#a32344e0120b2148cb649be85df1b2a34">halfedges_begin</a> () const </td></tr>
<tr class="memdesc:a32344e0120b2148cb649be85df1b2a34"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns start iterator for halfedges <br /></td></tr>
<tr class="separator:a32344e0120b2148cb649be85df1b2a34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0496259a0961b578bed1a422326f1264"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0496259a0961b578bed1a422326f1264"></a>
<a class="el" href="class_open_g_p_1_1_surface_mesh_1_1_halfedge__iterator.html">Halfedge_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_g_p_1_1_surface_mesh.html#a0496259a0961b578bed1a422326f1264">halfedges_end</a> () const </td></tr>
<tr class="memdesc:a0496259a0961b578bed1a422326f1264"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns end iterator for halfedges <br /></td></tr>
<tr class="separator:a0496259a0961b578bed1a422326f1264"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ed6c8ae83c67b452c7e3e24533d622c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1ed6c8ae83c67b452c7e3e24533d622c"></a>
<a class="el" href="class_open_g_p_1_1_surface_mesh_1_1_halfedge__container.html">Halfedge_container</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_g_p_1_1_surface_mesh.html#a1ed6c8ae83c67b452c7e3e24533d622c">halfedges</a> () const </td></tr>
<tr class="memdesc:a1ed6c8ae83c67b452c7e3e24533d622c"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns halfedge container for C++11 range-based for-loops <br /></td></tr>
<tr class="separator:a1ed6c8ae83c67b452c7e3e24533d622c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b5bff4cb258f6cf092eff82ef8c6bdc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1b5bff4cb258f6cf092eff82ef8c6bdc"></a>
<a class="el" href="class_open_g_p_1_1_surface_mesh_1_1_edge__iterator.html">Edge_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_g_p_1_1_surface_mesh.html#a1b5bff4cb258f6cf092eff82ef8c6bdc">edges_begin</a> () const </td></tr>
<tr class="memdesc:a1b5bff4cb258f6cf092eff82ef8c6bdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns start iterator for edges <br /></td></tr>
<tr class="separator:a1b5bff4cb258f6cf092eff82ef8c6bdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12b29ac46df4f2702545f462e39f1faa"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a12b29ac46df4f2702545f462e39f1faa"></a>
<a class="el" href="class_open_g_p_1_1_surface_mesh_1_1_edge__iterator.html">Edge_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_g_p_1_1_surface_mesh.html#a12b29ac46df4f2702545f462e39f1faa">edges_end</a> () const </td></tr>
<tr class="memdesc:a12b29ac46df4f2702545f462e39f1faa"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns end iterator for edges <br /></td></tr>
<tr class="separator:a12b29ac46df4f2702545f462e39f1faa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae78c15bb2d560895ec5805eaa37fc401"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae78c15bb2d560895ec5805eaa37fc401"></a>
<a class="el" href="class_open_g_p_1_1_surface_mesh_1_1_edge__container.html">Edge_container</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_g_p_1_1_surface_mesh.html#ae78c15bb2d560895ec5805eaa37fc401">edges</a> () const </td></tr>
<tr class="memdesc:ae78c15bb2d560895ec5805eaa37fc401"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns edge container for C++11 range-based for-loops <br /></td></tr>
<tr class="separator:ae78c15bb2d560895ec5805eaa37fc401"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69e9297f435da269b2940d630b4b4dba"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a69e9297f435da269b2940d630b4b4dba"></a>
<a class="el" href="class_open_g_p_1_1_surface_mesh_1_1_face__iterator.html">Face_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_g_p_1_1_surface_mesh.html#a69e9297f435da269b2940d630b4b4dba">faces_begin</a> () const </td></tr>
<tr class="memdesc:a69e9297f435da269b2940d630b4b4dba"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns start iterator for faces <br /></td></tr>
<tr class="separator:a69e9297f435da269b2940d630b4b4dba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e5f431c69d88d73e601a7403b45a341"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9e5f431c69d88d73e601a7403b45a341"></a>
<a class="el" href="class_open_g_p_1_1_surface_mesh_1_1_face__iterator.html">Face_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_g_p_1_1_surface_mesh.html#a9e5f431c69d88d73e601a7403b45a341">faces_end</a> () const </td></tr>
<tr class="memdesc:a9e5f431c69d88d73e601a7403b45a341"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns end iterator for faces <br /></td></tr>
<tr class="separator:a9e5f431c69d88d73e601a7403b45a341"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4542334df20f2b0d613f4035aeef1c46"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4542334df20f2b0d613f4035aeef1c46"></a>
<a class="el" href="class_open_g_p_1_1_surface_mesh_1_1_face__container.html">Face_container</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_g_p_1_1_surface_mesh.html#a4542334df20f2b0d613f4035aeef1c46">faces</a> () const </td></tr>
<tr class="memdesc:a4542334df20f2b0d613f4035aeef1c46"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns face container for C++11 range-based for-loops <br /></td></tr>
<tr class="separator:a4542334df20f2b0d613f4035aeef1c46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af90ac6206924527eab465ced759f9876"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af90ac6206924527eab465ced759f9876"></a>
<a class="el" href="class_open_g_p_1_1_surface_mesh_1_1_vertex__around__vertex__circulator.html">Vertex_around_vertex_circulator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_g_p_1_1_surface_mesh.html#af90ac6206924527eab465ced759f9876">vertices</a> (<a class="el" href="struct_open_g_p_1_1_surface_mesh_1_1_vertex.html">Vertex</a> v) const </td></tr>
<tr class="memdesc:af90ac6206924527eab465ced759f9876"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns circulator for vertices around vertex <code>v</code> <br /></td></tr>
<tr class="separator:af90ac6206924527eab465ced759f9876"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ded4b1d1d942acfe87aca39312dc8ce"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8ded4b1d1d942acfe87aca39312dc8ce"></a>
<a class="el" href="class_open_g_p_1_1_surface_mesh_1_1_halfedge__around__vertex__circulator.html">Halfedge_around_vertex_circulator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_g_p_1_1_surface_mesh.html#a8ded4b1d1d942acfe87aca39312dc8ce">halfedges</a> (<a class="el" href="struct_open_g_p_1_1_surface_mesh_1_1_vertex.html">Vertex</a> v) const </td></tr>
<tr class="memdesc:a8ded4b1d1d942acfe87aca39312dc8ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns circulator for outgoing halfedges around vertex <code>v</code> <br /></td></tr>
<tr class="separator:a8ded4b1d1d942acfe87aca39312dc8ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad47ff184f3a69335a186685b22cbdfb5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad47ff184f3a69335a186685b22cbdfb5"></a>
<a class="el" href="class_open_g_p_1_1_surface_mesh_1_1_face__around__vertex__circulator.html">Face_around_vertex_circulator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_g_p_1_1_surface_mesh.html#ad47ff184f3a69335a186685b22cbdfb5">faces</a> (<a class="el" href="struct_open_g_p_1_1_surface_mesh_1_1_vertex.html">Vertex</a> v) const </td></tr>
<tr class="memdesc:ad47ff184f3a69335a186685b22cbdfb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns circulator for faces around vertex <code>v</code> <br /></td></tr>
<tr class="separator:ad47ff184f3a69335a186685b22cbdfb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addd5a37cf781d21a25f06049b1c2bf32"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="addd5a37cf781d21a25f06049b1c2bf32"></a>
<a class="el" href="class_open_g_p_1_1_surface_mesh_1_1_vertex__around__face__circulator.html">Vertex_around_face_circulator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_g_p_1_1_surface_mesh.html#addd5a37cf781d21a25f06049b1c2bf32">vertices</a> (<a class="el" href="struct_open_g_p_1_1_surface_mesh_1_1_face.html">Face</a> f) const </td></tr>
<tr class="memdesc:addd5a37cf781d21a25f06049b1c2bf32"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns circulator for vertices of face <code>f</code> <br /></td></tr>
<tr class="separator:addd5a37cf781d21a25f06049b1c2bf32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb556fbd59d9a37022b1e59563e31018"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adb556fbd59d9a37022b1e59563e31018"></a>
<a class="el" href="class_open_g_p_1_1_surface_mesh_1_1_halfedge__around__face__circulator.html">Halfedge_around_face_circulator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_g_p_1_1_surface_mesh.html#adb556fbd59d9a37022b1e59563e31018">halfedges</a> (<a class="el" href="struct_open_g_p_1_1_surface_mesh_1_1_face.html">Face</a> f) const </td></tr>
<tr class="memdesc:adb556fbd59d9a37022b1e59563e31018"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns circulator for halfedges of face <code>f</code> <br /></td></tr>
<tr class="separator:adb556fbd59d9a37022b1e59563e31018"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Higher-level Topological Operations</div></td></tr>
<tr class="memitem:a86564712b32313fc9c3d866497376d34"><td class="memItemLeft" align="right" valign="top">HEADERONLY_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_g_p_1_1_surface_mesh.html#a86564712b32313fc9c3d866497376d34">is_triangle_mesh</a> () const </td></tr>
<tr class="separator:a86564712b32313fc9c3d866497376d34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c1c3e680e75c99fcd97a5f32a2ff9d4"><td class="memItemLeft" align="right" valign="top">HEADERONLY_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_g_p_1_1_surface_mesh.html#a8c1c3e680e75c99fcd97a5f32a2ff9d4">is_quad_mesh</a> () const </td></tr>
<tr class="separator:a8c1c3e680e75c99fcd97a5f32a2ff9d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a603eb43a3b793cf7fbfa09e2ce9b7047"><td class="memItemLeft" align="right" valign="top">HEADERONLY_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_g_p_1_1_surface_mesh.html#a603eb43a3b793cf7fbfa09e2ce9b7047">triangulate</a> ()</td></tr>
<tr class="separator:a603eb43a3b793cf7fbfa09e2ce9b7047"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade37ebf4124f7701dbe86e373fba4c30"><td class="memItemLeft" align="right" valign="top">HEADERONLY_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_g_p_1_1_surface_mesh.html#ade37ebf4124f7701dbe86e373fba4c30">triangulate</a> (<a class="el" href="struct_open_g_p_1_1_surface_mesh_1_1_face.html">Face</a> f)</td></tr>
<tr class="separator:ade37ebf4124f7701dbe86e373fba4c30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a355c86fd0511255f4fcc274f892ed037"><td class="memItemLeft" align="right" valign="top">HEADERONLY_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_g_p_1_1_surface_mesh.html#a355c86fd0511255f4fcc274f892ed037">is_collapse_ok</a> (<a class="el" href="struct_open_g_p_1_1_surface_mesh_1_1_halfedge.html">Halfedge</a> h)</td></tr>
<tr class="separator:a355c86fd0511255f4fcc274f892ed037"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9e79b6804f0c9877a66f3243c0f452b"><td class="memItemLeft" align="right" valign="top">HEADERONLY_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_g_p_1_1_surface_mesh.html#ac9e79b6804f0c9877a66f3243c0f452b">collapse</a> (<a class="el" href="struct_open_g_p_1_1_surface_mesh_1_1_halfedge.html">Halfedge</a> h)</td></tr>
<tr class="separator:ac9e79b6804f0c9877a66f3243c0f452b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a535bc2ad55eb7c716e92a8b4723ce650"><td class="memItemLeft" align="right" valign="top">HEADERONLY_INLINE <a class="el" href="struct_open_g_p_1_1_surface_mesh_1_1_vertex.html">Vertex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_g_p_1_1_surface_mesh.html#a535bc2ad55eb7c716e92a8b4723ce650">split</a> (<a class="el" href="struct_open_g_p_1_1_surface_mesh_1_1_face.html">Face</a> f, const Vec3 &amp;p)</td></tr>
<tr class="separator:a535bc2ad55eb7c716e92a8b4723ce650"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed5750c8742708c01d028f98b2543813"><td class="memItemLeft" align="right" valign="top">HEADERONLY_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_g_p_1_1_surface_mesh.html#aed5750c8742708c01d028f98b2543813">split</a> (<a class="el" href="struct_open_g_p_1_1_surface_mesh_1_1_face.html">Face</a> f, <a class="el" href="struct_open_g_p_1_1_surface_mesh_1_1_vertex.html">Vertex</a> v)</td></tr>
<tr class="separator:aed5750c8742708c01d028f98b2543813"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d4368f7faa1bc8356be123ed8f1c94e"><td class="memItemLeft" align="right" valign="top">HEADERONLY_INLINE <a class="el" href="struct_open_g_p_1_1_surface_mesh_1_1_vertex.html">Vertex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_g_p_1_1_surface_mesh.html#a1d4368f7faa1bc8356be123ed8f1c94e">split</a> (<a class="el" href="struct_open_g_p_1_1_surface_mesh_1_1_edge.html">Edge</a> e, const Vec3 &amp;p)</td></tr>
<tr class="separator:a1d4368f7faa1bc8356be123ed8f1c94e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba0edf67c7502c7aae34f90cc292ab2a"><td class="memItemLeft" align="right" valign="top">HEADERONLY_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_g_p_1_1_surface_mesh.html#aba0edf67c7502c7aae34f90cc292ab2a">split</a> (<a class="el" href="struct_open_g_p_1_1_surface_mesh_1_1_edge.html">Edge</a> e, <a class="el" href="struct_open_g_p_1_1_surface_mesh_1_1_vertex.html">Vertex</a> v)</td></tr>
<tr class="separator:aba0edf67c7502c7aae34f90cc292ab2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2f75d95ee3ed242556a919e7847d4a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_open_g_p_1_1_surface_mesh_1_1_halfedge.html">Halfedge</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_g_p_1_1_surface_mesh.html#ae2f75d95ee3ed242556a919e7847d4a8">insert_vertex</a> (<a class="el" href="struct_open_g_p_1_1_surface_mesh_1_1_edge.html">Edge</a> e, const Vec3 &amp;p)</td></tr>
<tr class="separator:ae2f75d95ee3ed242556a919e7847d4a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac031789707774634190bd8978b836197"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_open_g_p_1_1_surface_mesh_1_1_halfedge.html">Halfedge</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_g_p_1_1_surface_mesh.html#ac031789707774634190bd8978b836197">insert_vertex</a> (<a class="el" href="struct_open_g_p_1_1_surface_mesh_1_1_edge.html">Edge</a> e, <a class="el" href="struct_open_g_p_1_1_surface_mesh_1_1_vertex.html">Vertex</a> v)</td></tr>
<tr class="separator:ac031789707774634190bd8978b836197"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3982c136026a06d57588185ce1f35d42"><td class="memItemLeft" align="right" valign="top">HEADERONLY_INLINE <a class="el" href="struct_open_g_p_1_1_surface_mesh_1_1_halfedge.html">Halfedge</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_g_p_1_1_surface_mesh.html#a3982c136026a06d57588185ce1f35d42">insert_vertex</a> (<a class="el" href="struct_open_g_p_1_1_surface_mesh_1_1_halfedge.html">Halfedge</a> h, <a class="el" href="struct_open_g_p_1_1_surface_mesh_1_1_vertex.html">Vertex</a> v)</td></tr>
<tr class="separator:a3982c136026a06d57588185ce1f35d42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1472304554c931b09c916a597c3a7e73"><td class="memItemLeft" align="right" valign="top">HEADERONLY_INLINE <a class="el" href="struct_open_g_p_1_1_surface_mesh_1_1_halfedge.html">Halfedge</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_g_p_1_1_surface_mesh.html#a1472304554c931b09c916a597c3a7e73">insert_edge</a> (<a class="el" href="struct_open_g_p_1_1_surface_mesh_1_1_halfedge.html">Halfedge</a> h0, <a class="el" href="struct_open_g_p_1_1_surface_mesh_1_1_halfedge.html">Halfedge</a> h1)</td></tr>
<tr class="separator:a1472304554c931b09c916a597c3a7e73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb7fa784f9fd75a9e4395d67dce8a8f6"><td class="memItemLeft" align="right" valign="top">HEADERONLY_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_g_p_1_1_surface_mesh.html#abb7fa784f9fd75a9e4395d67dce8a8f6">is_flip_ok</a> (<a class="el" href="struct_open_g_p_1_1_surface_mesh_1_1_edge.html">Edge</a> e) const </td></tr>
<tr class="separator:abb7fa784f9fd75a9e4395d67dce8a8f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa952f403210c6c35c6caab79780489df"><td class="memItemLeft" align="right" valign="top">HEADERONLY_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_g_p_1_1_surface_mesh.html#aa952f403210c6c35c6caab79780489df">flip</a> (<a class="el" href="struct_open_g_p_1_1_surface_mesh_1_1_edge.html">Edge</a> e)</td></tr>
<tr class="separator:aa952f403210c6c35c6caab79780489df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1762612694c3d584498d5e6dcd86a611"><td class="memItemLeft" align="right" valign="top">HEADERONLY_INLINE unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_g_p_1_1_surface_mesh.html#a1762612694c3d584498d5e6dcd86a611">valence</a> (<a class="el" href="struct_open_g_p_1_1_surface_mesh_1_1_vertex.html">Vertex</a> v) const </td></tr>
<tr class="separator:a1762612694c3d584498d5e6dcd86a611"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab971f8f1f345645f50fe76fb54554377"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab971f8f1f345645f50fe76fb54554377"></a>
HEADERONLY_INLINE unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_g_p_1_1_surface_mesh.html#ab971f8f1f345645f50fe76fb54554377">valence</a> (<a class="el" href="struct_open_g_p_1_1_surface_mesh_1_1_face.html">Face</a> f) const </td></tr>
<tr class="memdesc:ab971f8f1f345645f50fe76fb54554377"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the valence of face <code>f</code> (its number of vertices) <br /></td></tr>
<tr class="separator:ab971f8f1f345645f50fe76fb54554377"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a055a572c24586f61d882b94d7b596f82"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a055a572c24586f61d882b94d7b596f82"></a>
HEADERONLY_INLINE <a class="el" href="struct_open_g_p_1_1_surface_mesh_1_1_halfedge.html">Halfedge</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_g_p_1_1_surface_mesh.html#a055a572c24586f61d882b94d7b596f82">find_halfedge</a> (<a class="el" href="struct_open_g_p_1_1_surface_mesh_1_1_vertex.html">Vertex</a> start, <a class="el" href="struct_open_g_p_1_1_surface_mesh_1_1_vertex.html">Vertex</a> end) const </td></tr>
<tr class="memdesc:a055a572c24586f61d882b94d7b596f82"><td class="mdescLeft">&#160;</td><td class="mdescRight">find the halfedge from start to end <br /></td></tr>
<tr class="separator:a055a572c24586f61d882b94d7b596f82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a648392d7936a0b61a9b536c6a9da5743"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a648392d7936a0b61a9b536c6a9da5743"></a>
HEADERONLY_INLINE <a class="el" href="struct_open_g_p_1_1_surface_mesh_1_1_edge.html">Edge</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_g_p_1_1_surface_mesh.html#a648392d7936a0b61a9b536c6a9da5743">find_edge</a> (<a class="el" href="struct_open_g_p_1_1_surface_mesh_1_1_vertex.html">Vertex</a> a, <a class="el" href="struct_open_g_p_1_1_surface_mesh_1_1_vertex.html">Vertex</a> b) const </td></tr>
<tr class="memdesc:a648392d7936a0b61a9b536c6a9da5743"><td class="mdescLeft">&#160;</td><td class="mdescRight">find the edge (a,b) <br /></td></tr>
<tr class="separator:a648392d7936a0b61a9b536c6a9da5743"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af43a3b800de0d8c10048266d9f9bcdc8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af43a3b800de0d8c10048266d9f9bcdc8"></a>
HEADERONLY_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_g_p_1_1_surface_mesh.html#af43a3b800de0d8c10048266d9f9bcdc8">delete_vertex</a> (<a class="el" href="struct_open_g_p_1_1_surface_mesh_1_1_vertex.html">Vertex</a> v)</td></tr>
<tr class="memdesc:af43a3b800de0d8c10048266d9f9bcdc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">deletes the vertex <code>v</code> from the mesh <br /></td></tr>
<tr class="separator:af43a3b800de0d8c10048266d9f9bcdc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0d9397f20d4350077e571e6d96b17c5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad0d9397f20d4350077e571e6d96b17c5"></a>
HEADERONLY_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_g_p_1_1_surface_mesh.html#ad0d9397f20d4350077e571e6d96b17c5">delete_edge</a> (<a class="el" href="struct_open_g_p_1_1_surface_mesh_1_1_edge.html">Edge</a> e)</td></tr>
<tr class="memdesc:ad0d9397f20d4350077e571e6d96b17c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">deletes the edge <code>e</code> from the mesh <br /></td></tr>
<tr class="separator:ad0d9397f20d4350077e571e6d96b17c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7a05aaf40335954750531a10497de2a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa7a05aaf40335954750531a10497de2a"></a>
HEADERONLY_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_g_p_1_1_surface_mesh.html#aa7a05aaf40335954750531a10497de2a">delete_face</a> (<a class="el" href="struct_open_g_p_1_1_surface_mesh_1_1_face.html">Face</a> f)</td></tr>
<tr class="memdesc:aa7a05aaf40335954750531a10497de2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">deletes the face <code>f</code> from the mesh <br /></td></tr>
<tr class="separator:aa7a05aaf40335954750531a10497de2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Geometry-related Functions</div></td></tr>
<tr class="memitem:ad7e1c0a6986d5cbceade7cd5e03f5ad0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad7e1c0a6986d5cbceade7cd5e03f5ad0"></a>
const Vec3 &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_g_p_1_1_surface_mesh.html#ad7e1c0a6986d5cbceade7cd5e03f5ad0">position</a> (<a class="el" href="struct_open_g_p_1_1_surface_mesh_1_1_vertex.html">Vertex</a> v) const </td></tr>
<tr class="memdesc:ad7e1c0a6986d5cbceade7cd5e03f5ad0"><td class="mdescLeft">&#160;</td><td class="mdescRight">position of a vertex (read only) <br /></td></tr>
<tr class="separator:ad7e1c0a6986d5cbceade7cd5e03f5ad0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc2a2bc3aac844db5e126a9cf1a9ac18"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acc2a2bc3aac844db5e126a9cf1a9ac18"></a>
Vec3 &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_g_p_1_1_surface_mesh.html#acc2a2bc3aac844db5e126a9cf1a9ac18">position</a> (<a class="el" href="struct_open_g_p_1_1_surface_mesh_1_1_vertex.html">Vertex</a> v)</td></tr>
<tr class="memdesc:acc2a2bc3aac844db5e126a9cf1a9ac18"><td class="mdescLeft">&#160;</td><td class="mdescRight">position of a vertex <br /></td></tr>
<tr class="separator:acc2a2bc3aac844db5e126a9cf1a9ac18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01bd845c233b6ad8e022ae176cc84463"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a01bd845c233b6ad8e022ae176cc84463"></a>
std::vector&lt; Vec3 &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_g_p_1_1_surface_mesh.html#a01bd845c233b6ad8e022ae176cc84463">points</a> ()</td></tr>
<tr class="memdesc:a01bd845c233b6ad8e022ae176cc84463"><td class="mdescLeft">&#160;</td><td class="mdescRight">vector of vertex positions <br /></td></tr>
<tr class="separator:a01bd845c233b6ad8e022ae176cc84463"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b9c9d0b258baa723e79b81ea81595fb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4b9c9d0b258baa723e79b81ea81595fb"></a>
HEADERONLY_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_g_p_1_1_surface_mesh.html#a4b9c9d0b258baa723e79b81ea81595fb">update_face_normals</a> ()</td></tr>
<tr class="memdesc:a4b9c9d0b258baa723e79b81ea81595fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute face normals by calling compute_face_normal(Face) for each face. <br /></td></tr>
<tr class="separator:a4b9c9d0b258baa723e79b81ea81595fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcae11982622bca9d153094e5ae35422"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adcae11982622bca9d153094e5ae35422"></a>
HEADERONLY_INLINE Vec3&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_g_p_1_1_surface_mesh.html#adcae11982622bca9d153094e5ae35422">compute_face_normal</a> (<a class="el" href="struct_open_g_p_1_1_surface_mesh_1_1_face.html">Face</a> f) const </td></tr>
<tr class="memdesc:adcae11982622bca9d153094e5ae35422"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute normal vector of face <code>f</code>. <br /></td></tr>
<tr class="separator:adcae11982622bca9d153094e5ae35422"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad43e3b5a7a5a17773bf967c6e36173c4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad43e3b5a7a5a17773bf967c6e36173c4"></a>
HEADERONLY_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_g_p_1_1_surface_mesh.html#ad43e3b5a7a5a17773bf967c6e36173c4">update_vertex_normals</a> ()</td></tr>
<tr class="memdesc:ad43e3b5a7a5a17773bf967c6e36173c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute vertex normals by calling compute_vertex_normal(Vertex) for each vertex. <br /></td></tr>
<tr class="separator:ad43e3b5a7a5a17773bf967c6e36173c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f2e68b4d661cdd0fcf550a9365bb74d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6f2e68b4d661cdd0fcf550a9365bb74d"></a>
HEADERONLY_INLINE Vec3&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_g_p_1_1_surface_mesh.html#a6f2e68b4d661cdd0fcf550a9365bb74d">compute_vertex_normal</a> (<a class="el" href="struct_open_g_p_1_1_surface_mesh_1_1_vertex.html">Vertex</a> v) const </td></tr>
<tr class="memdesc:a6f2e68b4d661cdd0fcf550a9365bb74d"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute normal vector of vertex <code>v</code>. <br /></td></tr>
<tr class="separator:a6f2e68b4d661cdd0fcf550a9365bb74d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acff33dca5886178a646e3eb3d228aca5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acff33dca5886178a646e3eb3d228aca5"></a>
HEADERONLY_INLINE Scalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_g_p_1_1_surface_mesh.html#acff33dca5886178a646e3eb3d228aca5">edge_length</a> (<a class="el" href="struct_open_g_p_1_1_surface_mesh_1_1_edge.html">Edge</a> e) const </td></tr>
<tr class="memdesc:acff33dca5886178a646e3eb3d228aca5"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute the length of edge <code>e</code>. <br /></td></tr>
<tr class="separator:acff33dca5886178a646e3eb3d228aca5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_open_g_p_1_1_global__properties"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_open_g_p_1_1_global__properties')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_open_g_p_1_1_global__properties.html">OpenGP::Global_properties</a></td></tr>
<tr class="memitem:a94c2b45401d07d0bad116aef5dc4919e inherit pub_methods_class_open_g_p_1_1_global__properties"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a94c2b45401d07d0bad116aef5dc4919e inherit pub_methods_class_open_g_p_1_1_global__properties"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_open_g_p_1_1_global__properties.html#a94c2b45401d07d0bad116aef5dc4919e">add_property</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:a94c2b45401d07d0bad116aef5dc4919e inherit pub_methods_class_open_g_p_1_1_global__properties"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic.  <a href="#a94c2b45401d07d0bad116aef5dc4919e">More...</a><br /></td></tr>
<tr class="separator:a94c2b45401d07d0bad116aef5dc4919e inherit pub_methods_class_open_g_p_1_1_global__properties"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1648fcbb6c4d2c2ef9f726b6a0c8045 inherit pub_methods_class_open_g_p_1_1_global__properties"><td class="memTemplParams" colspan="2"><a class="anchor" id="ae1648fcbb6c4d2c2ef9f726b6a0c8045"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ae1648fcbb6c4d2c2ef9f726b6a0c8045 inherit pub_methods_class_open_g_p_1_1_global__properties"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_open_g_p_1_1_global__properties.html#ae1648fcbb6c4d2c2ef9f726b6a0c8045">add_property</a> (const std::string &amp;name, const T &amp;initval)</td></tr>
<tr class="memdesc:ae1648fcbb6c4d2c2ef9f726b6a0c8045 inherit pub_methods_class_open_g_p_1_1_global__properties"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic with immediate initialization. <br /></td></tr>
<tr class="separator:ae1648fcbb6c4d2c2ef9f726b6a0c8045 inherit pub_methods_class_open_g_p_1_1_global__properties"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7af76b532e92e9396297bfabf6fdbcb9 inherit pub_methods_class_open_g_p_1_1_global__properties"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a7af76b532e92e9396297bfabf6fdbcb9 inherit pub_methods_class_open_g_p_1_1_global__properties"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_open_g_p_1_1_global__properties.html#a7af76b532e92e9396297bfabf6fdbcb9">get_property</a> (const std::string &amp;name)</td></tr>
<tr class="separator:a7af76b532e92e9396297bfabf6fdbcb9 inherit pub_methods_class_open_g_p_1_1_global__properties"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A halfedge data structure for polygonal meshes. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a1ce75b6bf0efe4f21ef2391399979759"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_open_g_p_1_1_surface_mesh_1_1_edge__property.html">Edge_property</a>&lt;T&gt; OpenGP::SurfaceMesh::add_edge_property </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>t</em> = <code>T()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>add a edge property of type <code>T</code> with name <code>name</code> and default value <code>t</code>. fails if a property named <code>name</code> exists already, since the name has to be unique. in this case it returns an invalid property </p>

</div>
</div>
<a class="anchor" id="a28a835c6dc3bc22e1311651bfe608bc4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_open_g_p_1_1_surface_mesh_1_1_face.html">SurfaceMesh::Face</a> OpenGP::SurfaceMesh::add_face </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_open_g_p_1_1_surface_mesh_1_1_vertex.html">Vertex</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vertices</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>add a new face with vertex list <code>vertices</code> </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="class_open_g_p_1_1_surface_mesh.html#aebc58f8d6601fc7c6953fc69f4e2b59f">add_triangle</a>, <a class="el" href="class_open_g_p_1_1_surface_mesh.html#aacfc2c77dbc0ee05098f55e7ffa063b1">add_quad</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a9bd42b305af291b75b08d643592365ac"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_open_g_p_1_1_surface_mesh_1_1_face__property.html">Face_property</a>&lt;T&gt; OpenGP::SurfaceMesh::add_face_property </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>t</em> = <code>T()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>add a face property of type <code>T</code> with name <code>name</code> and default value <code>t</code>. fails if a property named <code>name</code> exists already, since the name has to be unique. in this case it returns an invalid property </p>

</div>
</div>
<a class="anchor" id="a9820779f524dbd1ec4cfd886f1f7e5f8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_open_g_p_1_1_surface_mesh_1_1_halfedge__property.html">Halfedge_property</a>&lt;T&gt; OpenGP::SurfaceMesh::add_halfedge_property </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>t</em> = <code>T()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>add a halfedge property of type <code>T</code> with name <code>name</code> and default value <code>t</code>. fails if a property named <code>name</code> exists already, since the name has to be unique. in this case it returns an invalid property </p>

</div>
</div>
<a class="anchor" id="aacfc2c77dbc0ee05098f55e7ffa063b1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_open_g_p_1_1_surface_mesh_1_1_face.html">SurfaceMesh::Face</a> OpenGP::SurfaceMesh::add_quad </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_open_g_p_1_1_surface_mesh_1_1_vertex.html">Vertex</a>&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_open_g_p_1_1_surface_mesh_1_1_vertex.html">Vertex</a>&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_open_g_p_1_1_surface_mesh_1_1_vertex.html">Vertex</a>&#160;</td>
          <td class="paramname"><em>v3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_open_g_p_1_1_surface_mesh_1_1_vertex.html">Vertex</a>&#160;</td>
          <td class="paramname"><em>v4</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>add a new quad connecting vertices <code>v1</code>, <code>v2</code>, <code>v3</code>, <code>v4</code> </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="class_open_g_p_1_1_surface_mesh.html#aebc58f8d6601fc7c6953fc69f4e2b59f">add_triangle</a>, <a class="el" href="class_open_g_p_1_1_surface_mesh.html#a28a835c6dc3bc22e1311651bfe608bc4">add_face</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aebc58f8d6601fc7c6953fc69f4e2b59f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_open_g_p_1_1_surface_mesh_1_1_face.html">SurfaceMesh::Face</a> OpenGP::SurfaceMesh::add_triangle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_open_g_p_1_1_surface_mesh_1_1_vertex.html">Vertex</a>&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_open_g_p_1_1_surface_mesh_1_1_vertex.html">Vertex</a>&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_open_g_p_1_1_surface_mesh_1_1_vertex.html">Vertex</a>&#160;</td>
          <td class="paramname"><em>v3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>add a new triangle connecting vertices <code>v1</code>, <code>v2</code>, <code>v3</code> </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="class_open_g_p_1_1_surface_mesh.html#a28a835c6dc3bc22e1311651bfe608bc4">add_face</a>, <a class="el" href="class_open_g_p_1_1_surface_mesh.html#aacfc2c77dbc0ee05098f55e7ffa063b1">add_quad</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ac93a3b5012953c091ec40949a6f474a7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_open_g_p_1_1_surface_mesh_1_1_vertex__property.html">Vertex_property</a>&lt;T&gt; OpenGP::SurfaceMesh::add_vertex_property </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>t</em> = <code>T()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>add a vertex property of type <code>T</code> with name <code>name</code> and default value <code>t</code>. fails if a property named <code>name</code> exists already, since the name has to be unique. in this case it returns an invalid property </p>

</div>
</div>
<a class="anchor" id="a9741a73c925d629cbdb02893d38c6271"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_open_g_p_1_1_surface_mesh_1_1_halfedge.html">Halfedge</a> OpenGP::SurfaceMesh::ccw_rotated_halfedge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_open_g_p_1_1_surface_mesh_1_1_halfedge.html">Halfedge</a>&#160;</td>
          <td class="paramname"><em>h</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>returns the halfedge that is rotated counter-clockwise around the start vertex of <code>h</code>. it is the opposite halfedge of the previous halfedge of <code>h</code>. </p>

</div>
</div>
<a class="anchor" id="ac9e79b6804f0c9877a66f3243c0f452b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OpenGP::SurfaceMesh::collapse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_open_g_p_1_1_surface_mesh_1_1_halfedge.html">Halfedge</a>&#160;</td>
          <td class="paramname"><em>h</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Collapse the halfedge <code>h</code> by moving its start vertex into its target vertex. For non-boundary halfedges this function removes one vertex, three edges, and two faces. For boundary halfedges it removes one vertex, two edges and one face. </p><dl class="section attention"><dt>Attention</dt><dd>This function is only valid for triangle meshes. </dd>
<dd>
<a class="el" href="struct_open_g_p_1_1_surface_mesh_1_1_halfedge.html">Halfedge</a> collapses might lead to invalid faces. Call <a class="el" href="class_open_g_p_1_1_surface_mesh.html#a355c86fd0511255f4fcc274f892ed037">is_collapse_ok(Halfedge)</a> to be sure the collapse is legal. </dd>
<dd>
The removed items are only marked as deleted. You have to call <a class="el" href="class_open_g_p_1_1_surface_mesh.html#a50bae0a1df19ffd477fda198c7a667bb" title="remove deleted vertices/edges/faces ">garbage_collection()</a> to finally remove them. </dd></dl>

</div>
</div>
<a class="anchor" id="a91921c2d2a46f08f7c02456ca9275a9e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_open_g_p_1_1_surface_mesh_1_1_halfedge.html">Halfedge</a> OpenGP::SurfaceMesh::cw_rotated_halfedge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_open_g_p_1_1_surface_mesh_1_1_halfedge.html">Halfedge</a>&#160;</td>
          <td class="paramname"><em>h</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>returns the halfedge that is rotated clockwise around the start vertex of <code>h</code>. it is the next halfedge of the opposite halfedge of <code>h</code>. </p>

</div>
</div>
<a class="anchor" id="aafec0b6da843682831e0740409844a80"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_open_g_p_1_1_surface_mesh_1_1_edge__property.html">Edge_property</a>&lt;T&gt; OpenGP::SurfaceMesh::edge_property </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>t</em> = <code>T()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>if an edge property of type <code>T</code> with name <code>name</code> exists, it is returned. otherwise this property is added (with default value <code>t</code>) </p>

</div>
</div>
<a class="anchor" id="aaf2c8bf7e23b6419661bf69417165ef8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_open_g_p_1_1_surface_mesh_1_1_face__property.html">Face_property</a>&lt;T&gt; OpenGP::SurfaceMesh::face_property </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>t</em> = <code>T()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>if a face property of type <code>T</code> with name <code>name</code> exists, it is returned. otherwise this property is added (with default value <code>t</code>) </p>

</div>
</div>
<a class="anchor" id="aa952f403210c6c35c6caab79780489df"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OpenGP::SurfaceMesh::flip </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_open_g_p_1_1_surface_mesh_1_1_edge.html">Edge</a>&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flip edge <code>e:</code> Remove edge <code>e</code> and add an edge between the two vertices opposite to edge <code>e</code> of the two incident triangles. </p><dl class="section attention"><dt>Attention</dt><dd>This function is only valid for triangle meshes. </dd></dl>
<dl class="section see"><dt>See also</dt><dd>is_flip_ok(Edge) </dd></dl>

</div>
</div>
<a class="anchor" id="a861117410179fea7aeaa377d9eb83094"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_open_g_p_1_1_surface_mesh_1_1_edge__property.html">Edge_property</a>&lt;T&gt; OpenGP::SurfaceMesh::get_edge_property </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>get the edge property named <code>name</code> of type <code>T</code>. returns an invalid <a class="el" href="class_open_g_p_1_1_surface_mesh_1_1_vertex__property.html">Vertex_property</a> if the property does not exist or if the type does not match. </p>

</div>
</div>
<a class="anchor" id="a2ec6f27be502753c245aa81615b799d6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::type_info&amp; OpenGP::SurfaceMesh::get_edge_property_type </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>get the type_info <code>T</code> of edge property named <code></code>. returns an typeid(void) if the property does not exist or if the type does not match. </p>

</div>
</div>
<a class="anchor" id="a9dab64eda7de98f10f5b9cc9988a3b90"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_open_g_p_1_1_surface_mesh_1_1_face__property.html">Face_property</a>&lt;T&gt; OpenGP::SurfaceMesh::get_face_property </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>get the face property named <code>name</code> of type <code>T</code>. returns an invalid <a class="el" href="class_open_g_p_1_1_surface_mesh_1_1_vertex__property.html">Vertex_property</a> if the property does not exist or if the type does not match. </p>

</div>
</div>
<a class="anchor" id="ad5162436ae6ba4e5b6282790d979b265"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::type_info&amp; OpenGP::SurfaceMesh::get_face_property_type </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>get the type_info <code>T</code> of face property named <code></code>. returns an typeid(void) if the property does not exist or if the type does not match. </p>

</div>
</div>
<a class="anchor" id="a5d9c25281115f9859b0c08f30184f99f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_open_g_p_1_1_surface_mesh_1_1_halfedge__property.html">Halfedge_property</a>&lt;T&gt; OpenGP::SurfaceMesh::get_halfedge_property </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>get the halfedge property named <code>name</code> of type <code>T</code>. returns an invalid <a class="el" href="class_open_g_p_1_1_surface_mesh_1_1_vertex__property.html">Vertex_property</a> if the property does not exist or if the type does not match. </p>

</div>
</div>
<a class="anchor" id="a8cbf036a0782f154f3f66b1545d19ffc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::type_info&amp; OpenGP::SurfaceMesh::get_halfedge_property_type </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>get the type_info <code>T</code> of halfedge property named <code></code>. returns an typeid(void) if the property does not exist or if the type does not match. </p>

</div>
</div>
<a class="anchor" id="a49a79a62cd065f66edc0dff5ddb6687e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_open_g_p_1_1_surface_mesh_1_1_vertex__property.html">Vertex_property</a>&lt;T&gt; OpenGP::SurfaceMesh::get_vertex_property </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>get the vertex property named <code>name</code> of type <code>T</code>. returns an invalid <a class="el" href="class_open_g_p_1_1_surface_mesh_1_1_vertex__property.html">Vertex_property</a> if the property does not exist or if the type does not match. </p>

</div>
</div>
<a class="anchor" id="a84fb77097285be6cdd85d3505e81fbb8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::type_info&amp; OpenGP::SurfaceMesh::get_vertex_property_type </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>get the type_info <code>T</code> of vertex property named <code></code>. returns an typeid(void) if the property does not exist or if the type does not match. </p>

</div>
</div>
<a class="anchor" id="a12c37f7dc06cd9b8fd9efc56d1d1b330"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_open_g_p_1_1_surface_mesh_1_1_halfedge.html">Halfedge</a> OpenGP::SurfaceMesh::halfedge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_open_g_p_1_1_surface_mesh_1_1_vertex.html">Vertex</a>&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>returns an outgoing halfedge of vertex <code>v</code>. if <code>v</code> is a boundary vertex this will be a boundary halfedge. </p>

</div>
</div>
<a class="anchor" id="abbdd898243df2b8ef06ce23759f0b2c6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_open_g_p_1_1_surface_mesh_1_1_halfedge__property.html">Halfedge_property</a>&lt;T&gt; OpenGP::SurfaceMesh::halfedge_property </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>t</em> = <code>T()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>if a halfedge property of type <code>T</code> with name <code>name</code> exists, it is returned. otherwise this property is added (with default value <code>t</code>) </p>

</div>
</div>
<a class="anchor" id="a1472304554c931b09c916a597c3a7e73"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_open_g_p_1_1_surface_mesh_1_1_halfedge.html">SurfaceMesh::Halfedge</a> OpenGP::SurfaceMesh::insert_edge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_open_g_p_1_1_surface_mesh_1_1_halfedge.html">Halfedge</a>&#160;</td>
          <td class="paramname"><em>h0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_open_g_p_1_1_surface_mesh_1_1_halfedge.html">Halfedge</a>&#160;</td>
          <td class="paramname"><em>h1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>insert edge between the to-vertices v0 of h0 and v1 of h1. returns the new halfedge from v0 to v1. </p><dl class="section attention"><dt>Attention</dt><dd>h0 and h1 have to belong to the same face </dd></dl>

</div>
</div>
<a class="anchor" id="ae2f75d95ee3ed242556a919e7847d4a8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_open_g_p_1_1_surface_mesh_1_1_halfedge.html">Halfedge</a> OpenGP::SurfaceMesh::insert_vertex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_open_g_p_1_1_surface_mesh_1_1_edge.html">Edge</a>&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vec3 &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Subdivide the edge <code>e</code> = (v0,v1) by splitting it into the two edge (v0,p) and (p,v1). Note that this function does not introduce any other edge or faces. It simply splits the edge. Returns halfedge that points to <code>p</code>. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="class_open_g_p_1_1_surface_mesh.html#ac031789707774634190bd8978b836197">insert_vertex(Edge, Vertex)</a> </dd>
<dd>
<a class="el" href="class_open_g_p_1_1_surface_mesh.html#a3982c136026a06d57588185ce1f35d42">insert_vertex(Halfedge, Vertex)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ac031789707774634190bd8978b836197"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_open_g_p_1_1_surface_mesh_1_1_halfedge.html">Halfedge</a> OpenGP::SurfaceMesh::insert_vertex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_open_g_p_1_1_surface_mesh_1_1_edge.html">Edge</a>&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_open_g_p_1_1_surface_mesh_1_1_vertex.html">Vertex</a>&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Subdivide the edge <code>e</code> = (v0,v1) by splitting it into the two edge (v0,v) and (v,v1). Note that this function does not introduce any other edge or faces. It simply splits the edge. Returns halfedge that points to <code>p</code>. </p><dl class="section see"><dt>See also</dt><dd>insert_vertex(Edge, Vec3) </dd>
<dd>
<a class="el" href="class_open_g_p_1_1_surface_mesh.html#a3982c136026a06d57588185ce1f35d42">insert_vertex(Halfedge, Vertex)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a3982c136026a06d57588185ce1f35d42"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_open_g_p_1_1_surface_mesh_1_1_halfedge.html">SurfaceMesh::Halfedge</a> OpenGP::SurfaceMesh::insert_vertex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_open_g_p_1_1_surface_mesh_1_1_halfedge.html">Halfedge</a>&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_open_g_p_1_1_surface_mesh_1_1_vertex.html">Vertex</a>&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Subdivide the edge <code>e</code> = (v0,v1) by splitting it into the two edge (v0,v) and (v,v1). Note that this function does not introduce any other edge or faces. It simply splits the edge. Returns halfedge that points to <code>p</code>. </p><dl class="section see"><dt>See also</dt><dd>insert_vertex(Edge, Vec3) </dd>
<dd>
<a class="el" href="class_open_g_p_1_1_surface_mesh.html#ac031789707774634190bd8978b836197">insert_vertex(Edge, Vertex)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="afea5aedb652cc9e55aeae5dd2e6c7e6d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool OpenGP::SurfaceMesh::is_boundary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_open_g_p_1_1_surface_mesh_1_1_edge.html">Edge</a>&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>returns whether <code>e</code> is a boundary edge, i.e., if one of its halfedges is a boundary halfedge. </p>

</div>
</div>
<a class="anchor" id="a355c86fd0511255f4fcc274f892ed037"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool OpenGP::SurfaceMesh::is_collapse_ok </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_open_g_p_1_1_surface_mesh_1_1_halfedge.html">Halfedge</a>&#160;</td>
          <td class="paramname"><em>h</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>returns whether collapsing the halfedge <code>h</code> is topologically legal. </p><dl class="section attention"><dt>Attention</dt><dd>This function is only valid for triangle meshes. </dd></dl>

</div>
</div>
<a class="anchor" id="a78d91e464b9c7e86c38de6c6b7ccd9e9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool OpenGP::SurfaceMesh::is_deleted </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_open_g_p_1_1_surface_mesh_1_1_vertex.html">Vertex</a>&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>returns whether vertex <code>v</code> is deleted </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="class_open_g_p_1_1_surface_mesh.html#a50bae0a1df19ffd477fda198c7a667bb" title="remove deleted vertices/edges/faces ">garbage_collection()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a6714d5585eb08f837ed82f0360f93272"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool OpenGP::SurfaceMesh::is_deleted </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_open_g_p_1_1_surface_mesh_1_1_halfedge.html">Halfedge</a>&#160;</td>
          <td class="paramname"><em>h</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>returns whether halfedge <code>h</code> is deleted </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="class_open_g_p_1_1_surface_mesh.html#a50bae0a1df19ffd477fda198c7a667bb" title="remove deleted vertices/edges/faces ">garbage_collection()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a16d0de13a19aab692447dd17d582f874"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool OpenGP::SurfaceMesh::is_deleted </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_open_g_p_1_1_surface_mesh_1_1_edge.html">Edge</a>&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>returns whether edge <code>e</code> is deleted </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="class_open_g_p_1_1_surface_mesh.html#a50bae0a1df19ffd477fda198c7a667bb" title="remove deleted vertices/edges/faces ">garbage_collection()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a753af7604251aedf6f832671f7cb0cd1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool OpenGP::SurfaceMesh::is_deleted </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_open_g_p_1_1_surface_mesh_1_1_face.html">Face</a>&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>returns whether face <code>f</code> is deleted </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="class_open_g_p_1_1_surface_mesh.html#a50bae0a1df19ffd477fda198c7a667bb" title="remove deleted vertices/edges/faces ">garbage_collection()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="abb7fa784f9fd75a9e4395d67dce8a8f6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool OpenGP::SurfaceMesh::is_flip_ok </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_open_g_p_1_1_surface_mesh_1_1_edge.html">Edge</a>&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check whether flipping edge <code>e</code> is topologically </p><dl class="section attention"><dt>Attention</dt><dd>This function is only valid for triangle meshes. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_open_g_p_1_1_surface_mesh.html#aa952f403210c6c35c6caab79780489df">flip(Edge)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a8c1c3e680e75c99fcd97a5f32a2ff9d4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool OpenGP::SurfaceMesh::is_quad_mesh </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>returns whether the mesh a quad mesh. this function simply tests each face, and therefore is not very efficient. </p>

</div>
</div>
<a class="anchor" id="a86564712b32313fc9c3d866497376d34"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool OpenGP::SurfaceMesh::is_triangle_mesh </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>returns whether the mesh a triangle mesh. this function simply tests each face, and therefore is not very efficient. </p><dl class="section see"><dt>See also</dt><dd>trianglate(), <a class="el" href="class_open_g_p_1_1_surface_mesh.html#ade37ebf4124f7701dbe86e373fba4c30">triangulate(Face)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a18e3b47a0275b670f8b0eae7f3245c63"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool OpenGP::SurfaceMesh::read </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>read mesh from file <code>filename</code>. file extension determines file type. </p><dl class="section see"><dt>See also</dt><dd>write(const std::string&amp; filename) </dd></dl>

</div>
</div>
<a class="anchor" id="a535bc2ad55eb7c716e92a8b4723ce650"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HEADERONLY_INLINE <a class="el" href="struct_open_g_p_1_1_surface_mesh_1_1_vertex.html">Vertex</a> OpenGP::SurfaceMesh::split </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_open_g_p_1_1_surface_mesh_1_1_face.html">Face</a>&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vec3 &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Split the face <code>f</code> by first adding point <code>p</code> to the mesh and then inserting edges between <code>p</code> and the vertices of <code>f</code>. For a triangle this is a standard one-to-three split. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="class_open_g_p_1_1_surface_mesh.html#aed5750c8742708c01d028f98b2543813">split(Face, Vertex)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aed5750c8742708c01d028f98b2543813"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OpenGP::SurfaceMesh::split </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_open_g_p_1_1_surface_mesh_1_1_face.html">Face</a>&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_open_g_p_1_1_surface_mesh_1_1_vertex.html">Vertex</a>&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Split the face <code>f</code> by inserting edges between <code>p</code> and the vertices of <code>f</code>. For a triangle this is a standard one-to-three split. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="class_open_g_p_1_1_surface_mesh.html#a535bc2ad55eb7c716e92a8b4723ce650">split(Face, const Vec3&amp;)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a1d4368f7faa1bc8356be123ed8f1c94e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HEADERONLY_INLINE <a class="el" href="struct_open_g_p_1_1_surface_mesh_1_1_vertex.html">Vertex</a> OpenGP::SurfaceMesh::split </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_open_g_p_1_1_surface_mesh_1_1_edge.html">Edge</a>&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vec3 &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Split the edge <code>e</code> by first adding point <code>p</code> to the mesh and then connecting it to the two vertices of the adjacent triangles that are opposite to edge <code>e</code>. </p><dl class="section attention"><dt>Attention</dt><dd>This function is only valid for triangle meshes. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_open_g_p_1_1_surface_mesh.html#aba0edf67c7502c7aae34f90cc292ab2a">split(Edge, Vertex)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aba0edf67c7502c7aae34f90cc292ab2a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OpenGP::SurfaceMesh::split </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_open_g_p_1_1_surface_mesh_1_1_edge.html">Edge</a>&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_open_g_p_1_1_surface_mesh_1_1_vertex.html">Vertex</a>&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Split the edge <code>e</code> by connecting vertex <code>v</code> it to the two vertices of the adjacent triangles that are opposite to edge <code>e</code>. </p><dl class="section attention"><dt>Attention</dt><dd>This function is only valid for triangle meshes. </dd></dl>
<dl class="section see"><dt>See also</dt><dd>split(Edge, Vec3) </dd></dl>

</div>
</div>
<a class="anchor" id="a603eb43a3b793cf7fbfa09e2ce9b7047"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OpenGP::SurfaceMesh::triangulate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>triangulate the entire mesh, by calling <a class="el" href="class_open_g_p_1_1_surface_mesh.html#ade37ebf4124f7701dbe86e373fba4c30">triangulate(Face)</a> for each face. </p><dl class="section see"><dt>See also</dt><dd>trianglate(Face) </dd></dl>

</div>
</div>
<a class="anchor" id="ade37ebf4124f7701dbe86e373fba4c30"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OpenGP::SurfaceMesh::triangulate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_open_g_p_1_1_surface_mesh_1_1_face.html">Face</a>&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>triangulate the face <code>f</code> </p><dl class="section see"><dt>See also</dt><dd>trianglate() </dd></dl>

</div>
</div>
<a class="anchor" id="a1762612694c3d584498d5e6dcd86a611"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int OpenGP::SurfaceMesh::valence </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_open_g_p_1_1_surface_mesh_1_1_vertex.html">Vertex</a>&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>returns the valence (number of incident edges or neighboring vertices) of vertex <code>v</code>. </p>

</div>
</div>
<a class="anchor" id="a037d2df1a2ddf83297a81222de6e55c8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_open_g_p_1_1_surface_mesh_1_1_vertex__property.html">Vertex_property</a>&lt;T&gt; OpenGP::SurfaceMesh::vertex_property </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>t</em> = <code>T()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>if a vertex property of type <code>T</code> with name <code>name</code> exists, it is returned. otherwise this property is added (with default value <code>t</code>) </p>

</div>
</div>
<a class="anchor" id="a9f2f0dde61493534f3e9a939f9ce83ab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool OpenGP::SurfaceMesh::write </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>write mesh to file <code>filename</code>. file extensions determines file type. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="class_open_g_p_1_1_surface_mesh.html#a18e3b47a0275b670f8b0eae7f3245c63">read(const std::string&amp; filename)</a> </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/drebain/Workspace/research/OpenGPFork/src/OpenGP/SurfaceMesh/<a class="el" href="_surface_mesh_8h_source.html">SurfaceMesh.h</a></li>
<li>/home/drebain/Workspace/research/OpenGPFork/src/OpenGP/SurfaceMesh/SurfaceMesh.cpp</li>
</ul>
</div><!-- contents -->
<div id="footer">
  <!-- <address>
    <small>
      Copyright &copy; 2013
    </small>
  </address> -->
</div>
</body>
</html>
