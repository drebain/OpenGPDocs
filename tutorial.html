<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>OpenGP: SurfaceMesh Tutorial</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OpenGP
   &#160;<span id="projectnumber">1.1</span>
   </div>
   <div id="projectbrief">Open Geometry Processing Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="tutorial.html"><span>Tutorial</span></a></li>
      <li><a href="devel.html"><span>Development</span></a></li>
      <li><a href="annotated.html"><span>Reference&#160;Manual</span></a></li>
      <li><a href="https://github.com/OpenGP/OpenGP/issues"><span>Report&#160;Bug</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">SurfaceMesh Tutorial </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#surface_mesh_intro">Introduction</a></li>
<li class="level1"><a href="#surface_mesh_usage">Usage</a><ul><li class="level2"><a href="#surface_mesh_basics">Basics</a></li>
<li class="level2"><a href="#surface_mesh_io">File I/O</a></li>
<li class="level2"><a href="#surface_mesh_iterators">Iterators and Circulators</a></li>
<li class="level2"><a href="#surface_mesh_properties">Properties</a></li>
<li class="level2"><a href="#surface_mesh_connectivity_queries">Connectivity Queries</a></li>
<li class="level2"><a href="#surface_mesh_topology_operations">Topological Operations</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="surface_mesh_intro"></a>
Introduction</h1>
<p>In general, a polygonal surface mesh is composed of vertices, edges and faces as well as the incidence relationships between them. SurfaceMesh stores the connectivity information based on halfedges, i.e. pairs of directed edges with opposing direction. To be more precise:</p>
<ul>
<li>
Each vertex stores an outgoing halfedge. </li>
<li>
Each face stores an incident halfedge. </li>
<li>
Each halfedge stores its incident face, its target vertex, and its previous and next halfedges within the face. </li>
</ul>
<p>The halfedge connectivity is illustrated in the figure below:</p>
<div class="image">
<img src="halfedge-connectivity.png" alt="halfedge-connectivity.png"/>
<div class="caption">
Halfedge connectivity.</div></div>
<h1><a class="anchor" id="surface_mesh_usage"></a>
Usage</h1>
<p>In the following sections we describe the basic usage of SurfaceMesh by means of simple example programs and code excerpts.</p>
<h2><a class="anchor" id="surface_mesh_basics"></a>
Basics</h2>
<p>The very basic usage of SurfaceMesh is demonstrated in the example below. The program first instantiates a SurfaceMesh object as well as four vertex handles. These handles, as well as the handles for the other mesh entities <code>Halfedge</code>, <code>Edge</code>, and <code>Face</code> are basically indices. Four vertices are added to the mesh, as well as four triangular faces composing a tetrahedron. Finally, the number of vertices, edges, and faces is printed to standard output.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;OpenGP/SurfaceMesh/SurfaceMesh.h&gt;</span></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespace_open_g_p.html">OpenGP</a>;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <span class="comment">// instantiate a SurfaceMesh object</span></div><div class="line">    <a class="code" href="class_open_g_p_1_1_surface_mesh.html">SurfaceMesh</a> mesh;</div><div class="line"></div><div class="line">    <span class="comment">// instantiate 4 vertex handles</span></div><div class="line">    <a class="code" href="struct_open_g_p_1_1_surface_mesh_1_1_vertex.html">SurfaceMesh::Vertex</a> v0,v1,v2,v3;</div><div class="line"></div><div class="line">    <span class="comment">// add 4 vertices</span></div><div class="line">    v0 = mesh.<a class="code" href="class_open_g_p_1_1_surface_mesh.html#a84bfcf99e46da0ce35c520bf16ee3e4c">add_vertex</a>(Vec3(0,0,0));</div><div class="line">    v1 = mesh.<a class="code" href="class_open_g_p_1_1_surface_mesh.html#a84bfcf99e46da0ce35c520bf16ee3e4c">add_vertex</a>(Vec3(1,0,0));</div><div class="line">    v2 = mesh.<a class="code" href="class_open_g_p_1_1_surface_mesh.html#a84bfcf99e46da0ce35c520bf16ee3e4c">add_vertex</a>(Vec3(0,1,0));</div><div class="line">    v3 = mesh.<a class="code" href="class_open_g_p_1_1_surface_mesh.html#a84bfcf99e46da0ce35c520bf16ee3e4c">add_vertex</a>(Vec3(0,0,1));</div><div class="line"></div><div class="line">    <span class="comment">// add 4 triangular faces</span></div><div class="line">    mesh.<a class="code" href="class_open_g_p_1_1_surface_mesh.html#aebc58f8d6601fc7c6953fc69f4e2b59f">add_triangle</a>(v0,v1,v3);</div><div class="line">    mesh.<a class="code" href="class_open_g_p_1_1_surface_mesh.html#aebc58f8d6601fc7c6953fc69f4e2b59f">add_triangle</a>(v1,v2,v3);</div><div class="line">    mesh.<a class="code" href="class_open_g_p_1_1_surface_mesh.html#aebc58f8d6601fc7c6953fc69f4e2b59f">add_triangle</a>(v2,v0,v3);</div><div class="line">    mesh.<a class="code" href="class_open_g_p_1_1_surface_mesh.html#aebc58f8d6601fc7c6953fc69f4e2b59f">add_triangle</a>(v0,v2,v1);</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;vertices: &quot;</span> &lt;&lt; mesh.<a class="code" href="class_open_g_p_1_1_surface_mesh.html#a8f0f9d9b2e68891018676897efd6130f">n_vertices</a>() &lt;&lt; std::endl;</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;edges: &quot;</span>    &lt;&lt; mesh.<a class="code" href="class_open_g_p_1_1_surface_mesh.html#a1ed195cc9997d3578d3a166bff9a5e11">n_edges</a>()    &lt;&lt; std::endl;</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;faces: &quot;</span>    &lt;&lt; mesh.<a class="code" href="class_open_g_p_1_1_surface_mesh.html#a7c43b48dac0688a37c99de847b222532">n_faces</a>()    &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="surface_mesh_io"></a>
File I/O</h2>
<p>SurfaceMesh currently supports reading OFF, OBJ, and STL files. Write support is currently limited to OFF files. All I/O operations are handled by the SurfaceMesh::read() and SurfaceMesh::write() member functions, with the target file name being their only argument. An example is given below.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;OpenGP/SurfaceMesh/SurfaceMesh.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;OpenGP/MLogger.h&gt;</span></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespace_open_g_p.html">OpenGP</a>;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv) {</div><div class="line">    std::string in_file = (argc&gt;1) ? argv[1] : <span class="stringliteral">&quot;bunny.obj&quot;</span>;</div><div class="line">    std::string out_file = (argc&gt;2) ? argv[2] : <span class="stringliteral">&quot;output.obj&quot;</span>;</div><div class="line"></div><div class="line">    <span class="comment">// instantiate a SurfaceMesh object</span></div><div class="line">    <a class="code" href="class_open_g_p_1_1_surface_mesh.html">SurfaceMesh</a> mesh;</div><div class="line"></div><div class="line">    <span class="comment">// read a mesh specified as the first command line argument</span></div><div class="line">    <span class="keywordtype">bool</span> success = mesh.<a class="code" href="class_open_g_p_1_1_surface_mesh.html#a18e3b47a0275b670f8b0eae7f3245c63">read</a>(in_file);</div><div class="line">    CHECK(success);</div><div class="line"></div><div class="line">    <span class="comment">// ...</span></div><div class="line">    <span class="comment">// do fancy stuff with the mesh</span></div><div class="line">    <span class="comment">// ...</span></div><div class="line"></div><div class="line">    <span class="comment">// write the mesh to the file specified as second argument</span></div><div class="line">    mesh.<a class="code" href="class_open_g_p_1_1_surface_mesh.html#a9f2f0dde61493534f3e9a939f9ce83ab">write</a>(out_file);</div><div class="line">    CHECK(success);</div><div class="line"></div><div class="line">    mLogger() &lt;&lt; <span class="stringliteral">&quot;read:&quot;</span> &lt;&lt; in_file &lt;&lt; <span class="stringliteral">&quot;wrote:&quot;</span> &lt;&lt; out_file;</div><div class="line">    <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="surface_mesh_iterators"></a>
Iterators and Circulators</h2>
<p>In order to sequentially access mesh entities SurfaceMesh provides iterators for each entity type, namely <code>Vertex_iterator</code>, <code>Halfedge_iterator</code>, <code>Edge_iterator</code>, and <code>Face_iterator</code>. Similar to iterators, SurfaceMesh also provides circulators for the ordered enumeration of all incident vertices, halfedges, or faces around a given face or vertex. Since there is no clear begin- and end-circulator, <code>do-while</code> loops are used for circulators. The example below demonstrates the use of iterators and circulators for computing the mean valence of a mesh.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;OpenGP/SurfaceMesh/SurfaceMesh.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;OpenGP/MLogger.h&gt;</span></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespace_open_g_p.html">OpenGP</a>;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv) {</div><div class="line">    std::string file = (argc&gt;1) ? argv[1] : <span class="stringliteral">&quot;bunny.obj&quot;</span>;</div><div class="line"></div><div class="line">    <a class="code" href="class_open_g_p_1_1_surface_mesh.html">SurfaceMesh</a> mesh;</div><div class="line">    <span class="keywordtype">bool</span> success = mesh.<a class="code" href="class_open_g_p_1_1_surface_mesh.html#a18e3b47a0275b670f8b0eae7f3245c63">read</a>(file);</div><div class="line">    CHECK(success);</div><div class="line"></div><div class="line">    <span class="keywordtype">float</span> mean_valence = 0.0f;</div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> vertex_valence;</div><div class="line"></div><div class="line">    <span class="comment">// instantiate iterator and circulators</span></div><div class="line">    <a class="code" href="class_open_g_p_1_1_surface_mesh_1_1_vertex__iterator.html">SurfaceMesh::Vertex_iterator</a> vit;</div><div class="line">    <a class="code" href="class_open_g_p_1_1_surface_mesh_1_1_vertex__around__vertex__circulator.html">SurfaceMesh::Vertex_around_vertex_circulator</a> vc, vc_end;</div><div class="line"></div><div class="line">    <span class="comment">// loop over all vertices</span></div><div class="line">    <span class="keywordflow">for</span> (vit = mesh.<a class="code" href="class_open_g_p_1_1_surface_mesh.html#aaec7881d50ee98937e696f4fe0f50165">vertices_begin</a>(); vit != mesh.<a class="code" href="class_open_g_p_1_1_surface_mesh.html#a5c74d8232746b48b89aebb7b6e5f0cf3">vertices_end</a>(); ++vit) {</div><div class="line">        <span class="comment">// initialize circulators</span></div><div class="line">        vc = mesh.<a class="code" href="class_open_g_p_1_1_surface_mesh.html#aeae7436db9b2011facfbb21f539dab88">vertices</a>(*vit);</div><div class="line">        vc_end = vc;</div><div class="line"></div><div class="line">        <span class="comment">// reset counter</span></div><div class="line">        vertex_valence = 0;</div><div class="line"></div><div class="line">        <span class="comment">// loop over all incident vertices</span></div><div class="line">        <span class="keywordflow">do</span> {</div><div class="line">            ++vertex_valence;</div><div class="line">        } <span class="keywordflow">while</span> (++vc != vc_end);</div><div class="line"></div><div class="line">        <span class="comment">// sum up vertex valences</span></div><div class="line">        mean_valence += vertex_valence;</div><div class="line">    }</div><div class="line"></div><div class="line">    mean_valence /= mesh.<a class="code" href="class_open_g_p_1_1_surface_mesh.html#a8f0f9d9b2e68891018676897efd6130f">n_vertices</a>();</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;mean valence: &quot;</span> &lt;&lt; mean_valence &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="surface_mesh_properties"></a>
Properties</h2>
<p>Attaching additional attributes to mesh entities is important for many applications. SurfaceMesh supports properties by means of synchronized arrays that can be (de-)allocated dynamically at run-time. Property arrays are also used internally, e.g., to store vertex coordinates. The example program below shows how to access vertex coordinates through the (pre-defined) point property.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;OpenGP/SurfaceMesh/SurfaceMesh.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;OpenGP/MLogger.h&gt;</span></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespace_open_g_p.html">OpenGP</a>;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv) {</div><div class="line">    std::string file = (argc&gt;1) ? argv[1] : <span class="stringliteral">&quot;bunny.obj&quot;</span>;</div><div class="line">    </div><div class="line">    <a class="code" href="class_open_g_p_1_1_surface_mesh.html">SurfaceMesh</a> mesh;</div><div class="line">    <span class="keywordtype">bool</span> success = mesh.<a class="code" href="class_open_g_p_1_1_surface_mesh.html#a18e3b47a0275b670f8b0eae7f3245c63">read</a>(file);</div><div class="line">    CHECK(success);</div><div class="line"></div><div class="line">    <span class="comment">// get (pre-defined) property storing vertex positions</span></div><div class="line">    <a class="code" href="class_open_g_p_1_1_surface_mesh_1_1_vertex__property.html">SurfaceMesh::Vertex_property&lt;Vec3&gt;</a> points = mesh.<a class="code" href="class_open_g_p_1_1_surface_mesh.html#a49a79a62cd065f66edc0dff5ddb6687e">get_vertex_property</a>&lt;Vec3&gt;(<span class="stringliteral">&quot;v:point&quot;</span>);</div><div class="line"></div><div class="line">    <a class="code" href="class_open_g_p_1_1_surface_mesh_1_1_vertex__iterator.html">SurfaceMesh::Vertex_iterator</a> vit, vend = mesh.<a class="code" href="class_open_g_p_1_1_surface_mesh.html#a5c74d8232746b48b89aebb7b6e5f0cf3">vertices_end</a>();</div><div class="line"></div><div class="line">    Vec3 p(0,0,0);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (vit = mesh.<a class="code" href="class_open_g_p_1_1_surface_mesh.html#aaec7881d50ee98937e696f4fe0f50165">vertices_begin</a>(); vit != vend; ++vit) {</div><div class="line">        <span class="comment">// access point property like an array</span></div><div class="line">        p += points[*vit];</div><div class="line">    }</div><div class="line"></div><div class="line">    p /= mesh.<a class="code" href="class_open_g_p_1_1_surface_mesh.html#a8f0f9d9b2e68891018676897efd6130f">n_vertices</a>();</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;barycenter: &quot;</span> &lt;&lt; p &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p>The dynamic (de-)allocation of properties at run-time is managed by a set of four different functions:</p>
<dl>
<dt><code>add_<em>EntityType</em>_property&lt;<em>PropertyType</em>&gt;("<em>PropertyName</em>")</code>  </dt>
<dd>Allocates a new property for the given <em>EntityType</em> of the type <em>PropertyType</em> labeled by the <em>PropertyName</em> string. <br />
 <br />
  </dd>
<dt><code>get_<em>EntityType</em>_property&lt;<em>PropertyType</em>&gt;("<em>PropertyName</em>")</code>  </dt>
<dd>Returns a handle to an existing property. <br />
 <br />
  </dd>
<dt><code><em>EntityType</em>_property&lt;<em>PropertyType</em>&gt;("<em>PropertyName</em>")</code>  </dt>
<dd>Returns a handle to an existing property if the specified property already exists. If not, a new property is allocated and its handle is returned. <br />
 <br />
  </dd>
<dt><code>remove_<em>EntityType</em>_property(<em>PropertyHandle</em>)</code>  </dt>
<dd>Removes and the vertex property referenced by <em>PropertyHandle</em>. <br />
 <br />
  </dd>
</dl>
<p>Functions that allocate a new property take a default value for the property as an optional second argument.</p>
<p>The code excerpt below demonstrates how to allocate, use and remove a custom edge property.</p>
<div class="fragment"><div class="line">SurfaceMesh mesh;</div><div class="line"></div><div class="line"><span class="comment">// allocate property storing a point per edge</span></div><div class="line">SurfaceMesh::Edge_property&lt;Point&gt; edge_points = mesh.<a class="code" href="class_open_g_p_1_1_surface_mesh.html#a1ce75b6bf0efe4f21ef2391399979759">add_edge_property</a>&lt;Point&gt;(<span class="stringliteral">&quot;property-name&quot;</span>);</div><div class="line"></div><div class="line"><span class="comment">// access the edge property like an array</span></div><div class="line">SurfaceMesh::Edge e;</div><div class="line">edge_points[e] = Point(x,y,z);</div><div class="line"></div><div class="line"><span class="comment">// remove property and free memory</span></div><div class="line">mesh.remove_edge_property(edge_points);</div></div><!-- fragment --><h2><a class="anchor" id="surface_mesh_connectivity_queries"></a>
Connectivity Queries</h2>
<p>Commonly used connectivity queries such as retrieving the next halfedge or the target vertex of an halfedge are illustrated below.</p>
<table  class="modules">
<tr>
<td><div class="fragment"><div class="line">SurfaceMesh::Halfedge h;</div><div class="line">SurfaceMesh::Halfedge h0 = mesh.next_halfedge_handle(h);</div><div class="line">SurfaceMesh::Halfedge h1 = mesh.prev_halfedge_handle(h);</div><div class="line">SurfaceMesh::Halfedge h2 = mesh.opposite_halfedge_handle(h);</div><div class="line">SurfaceMesh::Face     f  = mesh.face_handle(h);</div><div class="line">SurfaceMesh::Vertex   v0 = mesh.from_vertex_handle(h);</div><div class="line">SurfaceMesh::Vertex   v1 = mesh.to_vertex_handle(h);</div></div><!-- fragment -->  </td><td><div class="image">
<img src="connectivity-queries.png" alt="connectivity-queries.png"/>
</div>
  <p class="endtd"></p>
</td></tr>
</table>
<h2><a class="anchor" id="surface_mesh_topology_operations"></a>
Topological Operations</h2>
<p>Surface mesh also offers higher-level topological operations, such as performing edge flips, edge splits, face splits, or halfedge collapses. The figure below illustrates some of these operations.</p>
<div class="image">
<img src="topology-changes.png" alt="topology-changes.png"/>
<div class="caption">
High-level operations changing the topology.</div></div>
<p> The corresponding member functions and their syntax is demonstrated in the pseudo-code below.</p>
<div class="fragment"><div class="line">SurfaceMesh::Vertex   v;</div><div class="line">SurfaceMesh::Edge     e;</div><div class="line">SurfaceMesh::Halfedge h;</div><div class="line">SurfaceMesh::Face     f;</div><div class="line"></div><div class="line">mesh.split(f, v);</div><div class="line">mesh.split(e, v);</div><div class="line">mesh.flip(e);</div><div class="line">mesh.collapse(h);</div></div><!-- fragment --><p>When entities are removed from the mesh due to topological changes, the member function <code>garbage_collection()</code> has to be called in order to ensure the consistency of the data structure. </p>
</div></div><!-- contents -->
<div id="footer">
  <!-- <address>
    <small>
      Copyright &copy; 2013
    </small>
  </address> -->
</div>
</body>
</html>
